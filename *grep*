-*- mode: grep; default-directory: "~/devel/funnel/" -*-
Grep started at Sat May  2 09:47:38

find . -type d \( -path \*/SCCS -o -path \*/RCS -o -path \*/CVS -o -path \*/MCVS -o -path \*/.svn -o -path \*/.git -o -path \*/.hg -o -path \*/.bzr -o -path \*/_MTN -o -path \*/_darcs -o -path \*/\{arch\} \) -prune -o \! -type d \( -name .\#\* -o -name \*.o -o -name \*\~ -o -name \*.bin -o -name \*.lbin -o -name \*.so -o -name \*.a -o -name \*.ln -o -name \*.blg -o -name \*.bbl -o -name \*.elc -o -name \*.lof -o -name \*.glo -o -name \*.idx -o -name \*.lot -o -name \*.fmt -o -name \*.tfm -o -name \*.class -o -name \*.fas -o -name \*.lib -o -name \*.mem -o -name \*.x86f -o -name \*.sparcf -o -name \*.dfsl -o -name \*.pfsl -o -name \*.d64fsl -o -name \*.p64fsl -o -name \*.lx64fsl -o -name \*.lx32fsl -o -name \*.dx64fsl -o -name \*.dx32fsl -o -name \*.fx64fsl -o -name \*.fx32fsl -o -name \*.sx64fsl -o -name \*.sx32fsl -o -name \*.wx64fsl -o -name \*.wx32fsl -o -name \*.fasl -o -name \*.ufsl -o -name \*.fsl -o -name \*.dxl -o -name \*.lo -o -name \*.la -o -name \*.gmo -o -name \*.mo -o -name \*.toc -o -name \*.aux -o -name \*.cp -o -name \*.fn -o -name \*.ky -o -name \*.pg -o -name \*.tp -o -name \*.vr -o -name \*.cps -o -name \*.fns -o -name \*.kys -o -name \*.pgs -o -name \*.tps -o -name \*.vrs -o -name \*.pyc -o -name \*.pyo \) -prune -o  -type f \( -iname \*.scala \) -exec grep -i -nH -e names {} +
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:15:    val names = blocks.map(_.name.sourceFile).distinct
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:16:    names.foldLeft(stringMap) { (map, n) => map + (n -> forSourceFile(n)) }
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:23:    val names = blocks.map(_.name).distinct
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:24:    names.foldLeft(nameMap) { (map, n) => map + (n -> forClass(n)) }
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:31:    val names = blocks.map(_.name.packageName).distinct
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:32:    names.foldLeft(stringMap) { (map, n) => map + (n -> forPackage(n)) }
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:39:    val names = blocks.map(_.name.projectName).distinct
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/CoverageData.scala:40:    names.foldLeft(stringMap) { (map, n) => map + (n -> forProject(n)) }
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/SourceFileHtmlReporter.scala:53:  @tailrec private def sourceLines(lineNum: Int, offset: Int, lines: List[String], blocks: List[CoveredBlock], usedNames: List[Name], acc: NodeSeq): NodeSeq = {
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/SourceFileHtmlReporter.scala:60:        val newNames = currBlocks.map(_.name).filterNot(usedNames.contains).distinct
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/SourceFileHtmlReporter.scala:61:        val newNamesHtml = newNames.map(n => <a id={ toHtmlId(n) }/>)
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/SourceFileHtmlReporter.scala:65:            <td>{ newNamesHtml }{ lineHtml }</td>
./.ensime_cache/dep-src/source-jars/com/sqality/scct/report/SourceFileHtmlReporter.scala:67:        sourceLines(lineNum + 1, maxOffset, tail, nextBlocks, usedNames ++ newNames, acc ++ rowHtml)
./.ensime_cache/dep-src/source-jars/org/scalacheck/Test.scala:238:      val names = Set("minSuccessfulTests", "s")
./.ensime_cache/dep-src/source-jars/org/scalacheck/Test.scala:243:      val names = Set("maxDiscardRatio", "r")
./.ensime_cache/dep-src/source-jars/org/scalacheck/Test.scala:251:      val names = Set("minSize", "n")
./.ensime_cache/dep-src/source-jars/org/scalacheck/Test.scala:256:      val names = Set("maxSize", "x")
./.ensime_cache/dep-src/source-jars/org/scalacheck/Test.scala:261:      val names = Set("workers", "w")
./.ensime_cache/dep-src/source-jars/org/scalacheck/Test.scala:266:      val names = Set("verbosity", "v")
./.ensime_cache/dep-src/source-jars/org/scalacheck/util/CmdLineParser.scala:24:    val names: Set[String]
./.ensime_cache/dep-src/source-jars/org/scalacheck/util/CmdLineParser.scala:57:    else opts.find(_.names.contains(s.drop(1)))
./.ensime_cache/dep-src/source-jars/org/scalacheck/util/CmdLineParser.scala:95:      println("  " + opt.names.map("-"+_).mkString(", ") + ": " + opt.help)
./.ensime_cache/dep-src/source-jars/org/scalactic/FailureMessages.scala:39:// to talk about method names, for example.
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:101: * with an error messages that includes the variable names if any are <code>null</code>. Here's an example:
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:179:     * @param variableNames names of variable passed as appear in source
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:182:    def macroRequireNonNull(variableNames: Array[String], arguments: Array[Any]) {
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:188:        val nullVariableNames = nullList.map { case (e, idx) =>
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:189:          variableNames(idx)
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:193:            FailureMessages("wasNull", UnquotedString(nullVariableNames(0)))
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:195:            val combinedVariableNames = Resources("and", nullVariableNames.head, nullVariableNames.last)
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:196:            FailureMessages("wereNull", UnquotedString(combinedVariableNames))
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:199:            val combinedVariableNames = Resources("commaAnd", nullVariableNames.dropRight(1).mkString(Resources("comma")), nullVariableNames.last)
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:200:            FailureMessages("wereNull", UnquotedString(combinedVariableNames))
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:365:    val variablesNamesArray =
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:392:    // Generate AST to call requirementsHelper.macroRequireNonNull and pass in both variable names and values array:
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:394:    // requirementsHelper.macroRequireNonNull(variableNamesArray, valuesArray)
./.ensime_cache/dep-src/source-jars/org/scalactic/Requirements.scala:401:        List(variablesNamesArray, argumentsArray)
./.ensime_cache/dep-src/source-jars/org/scalactic/Snapshots.scala:42: * <a href="SnapshotSeq.html"><code>SnapshotSeq</code></a>, whose <code>toString</code> lists the names
./.ensime_cache/dep-src/source-jars/org/scalatest/AbstractSuite.scala:118:  * A <code>Set</code> of test names. If this <code>Suite</code> contains no tests, this method returns an empty <code>Set</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/AbstractSuite.scala:122:  * test names in a well-defined order, the contract of this method does not required a defined order. Subclasses are free to
./.ensime_cache/dep-src/source-jars/org/scalatest/AbstractSuite.scala:123:  * implement this method and return test names in either a defined or undefined order.
./.ensime_cache/dep-src/source-jars/org/scalatest/AbstractSuite.scala:126:  def testNames: Set[String]
./.ensime_cache/dep-src/source-jars/org/scalatest/AbstractSuite.scala:135:   * A <code>Map</code> whose keys are <code>String</code> tag names with which tests in this <code>Suite</code> are marked, and
./.ensime_cache/dep-src/source-jars/org/scalatest/AbstractSuite.scala:136:   * whose values are the <code>Set</code> of test names marked with each tag.  If this <code>Suite</code> contains no tags, this
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductor.scala:293:  // Used to keep track of what names have been created so far, so that
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductor.scala:294:  // it can be enforced that the names are unique.
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductor.scala:295:  private final val threadNames = new CopyOnWriteArrayList[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductor.scala:332:        if (threadNames contains name)
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductor.scala:336:        threadNames add name
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductors.scala:504:    // Used to keep track of what names have been created so far, so that
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductors.scala:505:    // it can be enforced that the names are unique.
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductors.scala:506:    private final val threadNames = new CopyOnWriteArrayList[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductors.scala:543:          if (threadNames contains name)
./.ensime_cache/dep-src/source-jars/org/scalatest/concurrent/Conductors.scala:547:          threadNames add name
./.ensime_cache/dep-src/source-jars/org/scalatest/ConfigMapWrapperSuite.scala:101:   * Returns the result obtained from invoking <code>testNames</code> on an instance of the wrapped
./.ensime_cache/dep-src/source-jars/org/scalatest/ConfigMapWrapperSuite.scala:104:   * @return the result of invoking <code>testNames</code> on an instance of wrapped suite
./.ensime_cache/dep-src/source-jars/org/scalatest/ConfigMapWrapperSuite.scala:106:  override def testNames: Set[String] = wrappedSuite.testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/ConfigMapWrapperSuite.scala:120:   * @return the result of invoking <code>testNames</code> on an instance of wrapped suite
./.ensime_cache/dep-src/source-jars/org/scalatest/DiagrammedExprMacro.scala:174:    val byNamess = paramss(fun.tpe).map(_.map(_.asTerm.isByNameParam))
./.ensime_cache/dep-src/source-jars/org/scalatest/DiagrammedExprMacro.scala:175:    util.Try(byNamess(i)(j)).getOrElse(false)
./.ensime_cache/dep-src/source-jars/org/scalatest/DiagrammedExprMacro.scala:224:                case byName if arg.tpe.typeSymbol.fullName == "scala.Nothing" => byName // for by-names, just use back the original
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:81:  // Access to the testNamesList, testsMap, and tagsMap must be synchronized, because the test methods are invoked by
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:82:  // the primary constructor, but testNames, tags, and runTest get invoked directly or indirectly
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:85:  // all three collections--testNamesList, testsMap, and tagsMap--are immuable collections), then I put the Bundle
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:89:  // Test names are in reverse order of test registration method invocations
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:92:    val testNamesList: List[String],
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:97:    def unpack = (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:103:      testNamesList: List[String],
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:108:      new Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:127:      var (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:129:      updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:141:      var (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:143:      updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:155:      var (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:157:      updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:166:      var (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:168:      updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:456:    if (theSuite.testNames.size > 0)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:470:    // by testNames.
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:502:    val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:504:      updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, true))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:570:    val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:580:    updateAtomic(oldBundle, Bundle(newBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:586:      val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:587:      updateAtomic(oldBundle, Bundle(oldBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:594:    val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:609:    updateAtomic(oldBundle, Bundle(newBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:622:      val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:623:      updateAtomic(oldBundle, Bundle(oldBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:631:    val (_, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:642:    updateAtomic(oldBundle, Bundle(newBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:662:    var (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:677:    testNamesList ::= testName
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:680:    val tagNames = Set[String]() ++ testTags.map(_.name)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:681:    if (!tagNames.isEmpty)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:682:      tagsMap += (testName -> tagNames)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:684:    updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:700:    var (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:702:    val tagNames = Set[String]() ++ testTags.map(_.name)
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:703:    tagsMap += (testName -> (tagNames + IgnoreTagName))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:705:    updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:1021:    val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:1041:    updateAtomic(oldBundle, Bundle(newBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:1047:      val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:1048:      updateAtomic(oldBundle, Bundle(oldBranch, testNamesList, testsMap, tagsMap, registrationClosed))
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:1069:    val (currentBranch, testNamesList, testsMap, tagsMap, registrationClosed) = oldBundle.unpack
./.ensime_cache/dep-src/source-jars/org/scalatest/Engine.scala:1071:      updateAtomic(oldBundle, Bundle(currentBranch, testNamesList, testsMap, tagsMap, true))
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:1537: * @param nameInfo an optional <a href="NameInfo.html"><code>NameInfo</code></a> that if defined, provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:1630: * @param nameInfo an optional <a href="NameInfo.html"><code>NameInfo</code></a> that if defined, provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:1723: * @param nameInfo an optional <a href="NameInfo.html"><code>NameInfo</code></a> that if defined, provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:1805: * @param nameInfo an optional <a href="NameInfo.html"><code>NameInfo</code></a> that if defined, provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:1880: * @param nameInfo a <a href="NameInfo.html"><code>NameInfo</code></a> that provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:1955: * @param nameInfo a <a href="NameInfo.html"><code>NameInfo</code></a> that provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/events/Event.scala:2028: * @param nameInfo a <a href="NameInfo.html"><code>NameInfo</code></a> that provides names for the suite and optionally the test 
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:30: * @param namesOfArgs an optional list of string names for the arguments.
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:44:  namesOfArgs: Option[List[String]],
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:47:  messageFun, cause, failedCodeStackDepthFun, payload, undecoratedMessage, args, namesOfArgs
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:60:    namesOfArgs: Option[List[String]],
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:62: ) = this(messageFun, cause, failedCodeStackDepthFun, None, undecoratedMessage, args, namesOfArgs, labels)
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:81:        namesOfArgs,
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/GeneratorDrivenPropertyCheckFailedException.scala:106:        namesOfArgs,
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:28: * @param optionalArgNames an optional list of string names for the arguments.
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:41:  optionalArgNames: Option[List[String]]
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:55:    optionalArgNames: Option[List[String]]
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:56:   ) = this(messageFun, cause, failedCodeStackDepthFun, None, undecoratedMessage, args, optionalArgNames)
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:72:  if (optionalArgNames == null) throw new NullPointerException("optionalArgNames was null")
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:74:  optionalArgNames match {
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:75:    case Some(null) => throw new NullPointerException("optionalArgNames was a Some(null)")
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:80:   * A list of names for the arguments that caused the property check to fail.
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:83:   * If the <code>optionalArgNames</code> class parameter is defined, this method returns
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:89:  def argNames: List[String] =
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:90:    optionalArgNames match {
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/PropertyCheckFailedException.scala:91:      case Some(argNames) => argNames
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:33: * @param namesOfArgs a list of string names for the arguments
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:47:  namesOfArgs: List[String],
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:50:  messageFun, cause, failedCodeStackDepthFun, payload, undecoratedMessage, args, Some(namesOfArgs)
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:64:    namesOfArgs: List[String],
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:66:  ) = this(messageFun, cause, failedCodeStackDepthFun, None, undecoratedMessage, args, namesOfArgs, row)
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:85:        namesOfArgs,
./.ensime_cache/dep-src/source-jars/org/scalatest/exceptions/TableDrivenPropertyCheckFailedException.scala:110:        namesOfArgs,
./.ensime_cache/dep-src/source-jars/org/scalatest/FailureMessages.scala:41:// to talk about method names, for example.
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:39: * @param tagsToInclude an optional <code>Set</code> of <code>String</code> tag names to include (<em>i.e.</em>, not filter out) when filtering tests
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:40: * @param tagsToExclude a <code>Set</code> of <code>String</code> tag names to exclude (<em>i.e.</em>, filter out) when filtering tests
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:72:  private def includedTestNames(testNamesAsList: List[String], tags: Map[String, Set[String]]): List[String] = 
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:74:      case None => testNamesAsList
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:77:          testName <- testNamesAsList
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:84:  private def verifyPreconditionsForMethods(testNames: Set[String], tags: Map[String, Set[String]]) {
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:108:  private[scalatest] def mergeTestDynamicTags(tags: Map[String, Set[String]], suiteId: String, testNames: Set[String]): Map[String, Set[String]] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:118:        Map() ++ testNames.map(tn => (tn, suiteTags))
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:127:   * Filter test names based on their tags.
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:142:   * for ((testName, ignoreTest) <- filter(testNames, tags))
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:149:   * @param testNames test names to be filtered
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:150:   * @param tags a map from test name to tags, containing only test names included in the <code>testNames</code> set, and
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:151:   *   only test names that have at least one tag
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:155:  @deprecated("Please use the apply method that takes a suiteId instead, the one with this signature: def apply(testNames: Set[String], testTags: Map[String, Set[String]], suiteId: String): List[(String, Boolean)]")
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:156:  def apply(testNames: Set[String], tags: Map[String, Set[String]]): List[(String, Boolean)] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:158:    verifyPreconditionsForMethods(testNames, tags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:160:    val testNamesAsList = testNames.toList // to preserve the order
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:163:        testName <- includedTestNames(testNamesAsList, tags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:172:  def apply(testNames: Set[String], tags: Map[String, Set[String]], suiteId: String): List[(String, Boolean)] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:173:    val testTags: Map[String, Set[String]] = mergeTestDynamicTags(tags, suiteId, testNames)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:174:    verifyPreconditionsForMethods(testNames, testTags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:176:    val testNamesAsList = testNames.toList // to preserve the order
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:179:        testName <- includedTestNames(testNamesAsList, testTags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:215:   * @param tags a map from test name to tags, containing only test names that have at least one tag
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:238:   * Returns the number of tests that should be run after the passed <code>testNames</code> and <code>tags</code> have been filtered
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:247:   * @param testNames test names to be filtered
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:248:   * @param tags a map from test name to tags, containing only test names included in the <code>testNames</code> set, and
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:249:   *   only test names that have at least one tag
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:253:  @deprecated("Please use the runnableTestCount method that takes a suiteId instead, the one with this signature: def runnableTestCount(testNames: Set[String], testTags: Map[String, Set[String]], suiteId: String): Int")
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:254:  def runnableTestCount(testNames: Set[String], tags: Map[String, Set[String]]): Int = {
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:256:    verifyPreconditionsForMethods(testNames, tags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:258:    val testNamesAsList = testNames.toList // to preserve the order
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:261:        testName <- includedTestNames(testNamesAsList, tags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:268:  def runnableTestCount(testNames: Set[String], testTags: Map[String, Set[String]], suiteId: String): Int = {
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:269:    val tags: Map[String, Set[String]] = mergeTestDynamicTags(testTags, suiteId, testNames)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:270:    verifyPreconditionsForMethods(testNames, tags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:272:    val testNamesAsList = testNames.toList // to preserve the order
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:275:        testName <- includedTestNames(testNamesAsList, tags)
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:290: * @param tagsToInclude an optional <code>Set</code> of <code>String</code> tag names to include (<em>i.e.</em>, not filter out) when filtering tests
./.ensime_cache/dep-src/source-jars/org/scalatest/Filter.scala:291: * @param tagsToExclude a <code>Set</code> of <code>String</code> tag names to exclude (<em>i.e.</em>, filter out) when filtering tests
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:114:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2029:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2046:   * A <code>Map</code> whose keys are <code>String</code> tag names to which tests in this <code>FlatSpec</code> belong, and values
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2047:   * the <code>Set</code> of test names that belong to each tag. If this <code>fixture.FlatSpec</code> contains no tags, this method returns an empty <code>Map</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2065:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2106:   * This method takes an <code>args</code> that contains a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2113:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2118:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2119:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2138:   * An immutable <code>Set</code> of test names. If this <code>fixture.FlatSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2142:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2143:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2148:   * @return the <code>Set</code> of test names
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2150:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FlatSpecLike.scala:2152:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:115:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:138:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:461:   * A <code>Map</code> whose keys are <code>String</code> tag names to which tests in this <code>FreeSpec</code> belong, and values
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:462:   * the <code>Set</code> of test names that belong to each tag. If this <code>FreeSpec</code> contains no tags, this method returns an empty <code>Map</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:480:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:521:   * This method takes an <code>args</code> that contains a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:528:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:533:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:534:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:553:   * An immutable <code>Set</code> of test names. If this <code>fixture.FreeSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:557:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:558:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:563:   * @return the <code>Set</code> of test names
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:565:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/FreeSpecLike.scala:567:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:139:   * An immutable <code>Set</code> of test names. If this <code>fixture.PropSpec</code> contains no tests, this method returns an empty <code>Set</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:142:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's iterator will
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:143:   * return those names in the order in which the tests were registered.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:146:   * @return the <code>Set</code> of test names
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:148:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:150:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:185:   * A <code>Map</code> whose keys are <code>String</code> tag names to which tests in this <code>fixture.PropSpec</code> belong, and values
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:186:   * the <code>Set</code> of test names that belong to each tag. If this <code>fixture.PropSpec</code> contains no tags, this method returns an empty
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:213:   * This method takes an <code>args</code> that contains a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:220:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:225:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/PropSpecLike.scala:226:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Spec.scala:275:  // https://github.com/scala/scala/blob/master/src/reflect/scala/reflect/internal/StdNames.scala#L47
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:108:// TODO: Detect duplicate test names, one with fixture param and one without.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:212:   * An immutable <code>Set</code> of test names. If this <code>Spec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:216:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:217:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:238:   * Invoking <code>testNames</code> on this <code>Spec</code> will yield a set that contains the following
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:252:   * @return the <code>Set</code> of test names
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:254:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:257:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:264:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:307:   * <li>the size of the <code>testNames</code> <code>List</code>, minus the number of tests marked as ignored and
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:328:   * A <code>Map</code> whose keys are <code>String</code> tag names to which tests in this <code>Spec</code> belong, and values
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/SpecLike.scala:329:   * the <code>Set</code> of test names that belong to each tag. If this <code>Spec</code> contains no tags, this method returns an empty <code>Map</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:176:   * A <code>Set</code> of test names. If this <code>fixture.Suite</code> contains no tests, this method returns an empty <code>Set</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:186:   * Here are a few method signatures and the names that this trait's implementation assigns them:
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:205:   * This trait's implementation of this method returns an immutable <code>Set</code> of all such names, excluding the name
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:206:   * <code>testNames</code>. The iterator obtained by invoking <code>elements</code> on this
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:207:   * returned <code>Set</code> will produce the test names in their <em>natural order</em>, as determined by <code>String</code>'s
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:215:   * test names in a well-defined order, the contract of this method does not required a defined order. Subclasses are free to
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:216:   * override this method and return test names in an undefined order, or in a defined order that's different from <code>String</code>'s
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:221:   * Subclasses may override this method to produce test names in a custom manner. One potential reason to override <code>testNames</code> is
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:258:   * The above <code>FreeSpec</code> contains two tests, both nested inside the same two scopes. The outermost scope names
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:269:   * Therefore, the names of these two tests are:
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:284:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:296:      // Factored out to share code with Suite.testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:297:      val (isInstanceMethod, simpleName, firstFour, paramTypes, hasNoParams, isTestNames, isTestTags, isTestDataFor) = isTestMethodGoodies(m)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:300:      // testNames(Object) and testNames(Object, Informer). Reason is if I didn't discover these
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/Suite.scala:302:      isInstanceMethod && (firstFour == "test") && !isTestDataFor && ((hasNoParams && !isTestNames && !isTestTags) ||
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:115:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:138:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1047:   * A <code>Map</code> whose keys are <code>String</code> tag names to which tests in this <code>WordSpec</code> belong, and values
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1048:   * the <code>Set</code> of test names that belong to each tag. If this <code>fixture.WordSpec</code> contains no tags, this method returns an empty <code>Map</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1066:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1107:   * This method takes an <code>args</code> that contains a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1114:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1119:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1120:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1139:   * An immutable <code>Set</code> of test names. If this <code>fixture.WordSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1143:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1144:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1149:   * @return the <code>Set</code> of test names
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1151:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/fixture/WordSpecLike.scala:1153:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:35: * but the test names must be written in a specification style: &ldquo;X should Y,&rdquo; &ldquo;A must B,&rdquo; <em>etc.  </em>
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:616: * A <code>FlatSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:622: * will probably want to use tag names on your test functions that match. To do so, simply 
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:623: * pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:624: * defined tag annotation interfaces with fully qualified names, <code>com.mycompany.tags.SlowTest</code> and
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:764: *     transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:855: * are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:982: *         val fileNames = currDir.list()
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpec.scala:983: *         info("Dir snapshot: " + fileNames.mkString(", "))
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:111:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1593:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1610:   * A <code>Map</code> whose keys are <code>String</code> names of tagged tests and whose associated values are
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1630:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1677:   * This method takes a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1684:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1689:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1690:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1699:   * <li><code>testName</code> - the <code>String</code> name of the test to run (which will be one of the names in the <code>testNames</code> <code>Set</code>)</li>
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1718:   * An immutable <code>Set</code> of test names. If this <code>FlatSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1722:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1723:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1742:   * Invoking <code>testNames</code> on this <code>FlatSpec</code> will yield a set that contains the following
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1753:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/FlatSpecLike.scala:1755:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:113:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:136:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:336:   * A <code>Map</code> whose keys are <code>String</code> names of tagged tests and whose associated values are
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:356:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:403:   * This method takes a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:410:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:415:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:416:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:425:   * <li><code>testName</code> - the <code>String</code> name of the test to run (which will be one of the names in the <code>testNames</code> <code>Set</code>)</li>
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:445:   * An immutable <code>Set</code> of test names. If this <code>FreeSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:449:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:450:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:471:   * Invoking <code>testNames</code> on this <code>FreeSpec</code> will yield a set that contains the following
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:480:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/FreeSpecLike.scala:482:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/Matchers.scala:142: * The old fully qualified names will continue to work during a lengthy deprecation cycle, but
./.ensime_cache/dep-src/source-jars/org/scalatest/Matchers.scala:173: * conflict with fields and methods in your existing classes and cause a compiler error. Such issues can usually be easily fixed locally with simple renames or refactors,
./.ensime_cache/dep-src/source-jars/org/scalatest/ParallelTestExecution.scala:87:            val testSortingReporter = new TestSortingReporter(suiteId, args.reporter, sortingTimeout, testNames.size, args.distributedSuiteSorter, System.err)
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:102:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:125:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:395:   * An immutable <code>Set</code> of test names. If this <code>FreeSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:405:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:406:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:427:   * Invoking <code>testNames</code> on this <code>FreeSpec</code> will yield a set that contains the following
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:441:  final override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:444:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:458:   * This trait's implementation of this method returns the size of the <code>testNames</code> <code>List</code>, minus
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:487:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:512:   * A <code>Map</code> whose keys are <code>String</code> tag names to which tests in this <code>path.FreeSpec</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/path/FreeSpecLike.scala:513:   * belong, and values the <code>Set</code> of test names that belong to each tag. If this <code>path.FreeSpec</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:370:  private[prop] def doCheck(p: Prop, prms: Test.Parameters, stackDepthFileName: String, stackDepthMethodName: String, argNames: Option[List[String]] = None) {
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:414:              prettyArgs(getArgsWithSpecifiedNames(argNames, scalaCheckArgs)) + "\n" +
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:439:              prettyArgs(getArgsWithSpecifiedNames(argNames, scalaCheckArgs)) + "\n" +
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:467:  private def getArgsWithSpecifiedNames(argNames: Option[List[String]], scalaCheckArgs: List[Arg[Any]]) = {
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:468:    if (argNames.isDefined) {
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:469:      // length of scalaCheckArgs should equal length of argNames
./.ensime_cache/dep-src/source-jars/org/scalatest/prop/Checkers.scala:470:      val zipped = argNames.get zip scalaCheckArgs
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpec.scala:531: * A <code>PropSpec</code>'s tests may be classified into groups by <em>tagging</em> them with string names.
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpec.scala:537: * will probably want to use tag names on your test functions that match. To do so, simply 
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpec.scala:538: * pass the fully qualified names of the tag interfaces to the <code>Tag</code> constructor. For example, if you've
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpec.scala:539: * defined tag annotation interfaces with fully qualified names, <code>com.mycompany.tags.SlowTest</code> and
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpec.scala:688: *     transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpecLike.scala:135:  * An immutable <code>Set</code> of test names. If this <code>PropSpec</code> contains no tests, this method returns an empty <code>Set</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpecLike.scala:138:  * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's iterator will
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpecLike.scala:139:  * return those names in the order in which the tests were registered.
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpecLike.scala:142:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpecLike.scala:144:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/PropSpecLike.scala:179:   * A <code>Map</code> whose keys are <code>String</code> names of tagged tests and whose associated values are
./.ensime_cache/dep-src/source-jars/org/scalatest/RandomTestOrder.scala:187:        val testSortingReporter = new TestSortingReporter(suiteId, args.reporter, sortingTimeout, testNames.size, args.distributedSuiteSorter, System.err)
./.ensime_cache/dep-src/source-jars/org/scalatest/Reporter.scala:64: * and <code>TestFailed</code> event names
./.ensime_cache/dep-src/source-jars/org/scalatest/Reporter.scala:80: * and <code>SuiteCompleted</code> event names
./.ensime_cache/dep-src/source-jars/org/scalatest/Shell.scala:91: * names, for example:
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:67: * with a nested singleton object, and a test with a method. The names of both <em>scope objects</em> and <em>test methods</em>
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:107: * <code>runTest</code>, and <code>testNames</code> all ensure that scopes and tests have already been discovered prior to doing anything
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:112: * A scope names, or gives more information about, the <em>subject</em> (class or other entity) you are specifying
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:176: * <em>Note: The approach of using backticks around test method names to make it easier to write descriptive test names was
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:555: * A <code>Spec</code>'s tests may be classified into groups by <em>tagging</em> them with string names. When executing
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:709: *     transform the outcome of tests, retry tests, make decisions based on test names, tags, or other test data.
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:802: * are part of the fixture, but if you prefer, you can import the the members with &ldquo;<code>import f._</code>&rdquo; and use the names directly.
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:939: *         val fileNames = currDir.list()
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:940: *         info("Dir snapshot: " + fileNames.mkString(", "))
./.ensime_cache/dep-src/source-jars/org/scalatest/Spec.scala:1435:  // https://github.com/scala/scala/blob/master/src/reflect/scala/reflect/internal/StdNames.scala#L47
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:195:   * An immutable <code>Set</code> of test names. If this <code>Spec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:199:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:200:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:221:   * Invoking <code>testNames</code> on this <code>Spec</code> will yield a set that contains the following
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:230:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:233:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:240:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/SpecLike.scala:279:   * A <code>Map</code> whose keys are <code>String</code> names of tagged tests and whose associated values are
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:520: * <li><code>testNames</code> - override this method to specify the <code>Suite</code>'s test names in a custom way.</li>
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:528: * For example, this trait's implementation of <code>testNames</code> performs reflection to discover methods starting with <code>test</code>,
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:529: * and places these in a <code>Set</code> whose iterator returns the names in alphabetical order. If you wish to run tests in a different
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:531: * <code>testBeta</code> has run, you can override <code>testNames</code> so that it returns a <code>Set</code> whose iterator returns
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:533: * in the order they come out of the <code>testNames</code> <code>Set</code> iterator.)
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:538: * the style of Java's JUnit 4 or TestNG. If so, you can override <code>testNames</code> to discover tests using either of these two APIs
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:548: * To facilitate this style of writing tests, <code>FunSuite</code> overrides <code>testNames</code>, <code>runTest</code>, and <code>run</code> such that you can 
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:802:        testNames.filter { s =>
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:909:   * A <code>Map</code> whose keys are <code>String</code> names of tests that are tagged and
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:910:   * whose associated values are the <code>Set</code> of tag names for the test.  If a test has no associated tags, its name
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:933:    val testNameSet = testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:936:      (for (testName <- testNameSet; if !getTags(testName).isEmpty)
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:950:   * A <code>Set</code> of test names. If this <code>Suite</code> contains no tests, this method returns an empty <code>Set</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:958:   * method takes a <code>Informer</code>. Here are a few method signatures and the names that this trait's implementation assigns them:
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:971:   * This trait's implementation of this method returns an immutable <code>Set</code> of all such names, excluding the name
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:972:   * <code>testNames</code>. The iterator obtained by invoking <code>elements</code> on this
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:973:   * returned <code>Set</code> will produce the test names in their <em>natural order</em>, as determined by <code>String</code>'s
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:981:   * test names in a well-defined order, the contract of this method does not required a defined order. Subclasses are free to
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:982:   * override this method and return test names in an undefined order, or in a defined order that's different from <code>String</code>'s
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:987:   * Subclasses may override this method to produce test names in a custom manner. One potential reason to override <code>testNames</code> is
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1024:   * The above <code>FreeSpec</code> contains two tests, both nested inside the same two scopes. The outermost scope names
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1035:   * Therefore, the names of these two tests are:
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1050:  def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1054:      // Factored out to share code with fixture.Suite.testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1055:      val (isInstanceMethod, simpleName, firstFour, paramTypes, hasNoParams, isTestNames, isTestTags, isTestDataFor) = isTestMethodGoodies(m)
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1057:      isInstanceMethod && (firstFour == "test") && !isTestDataFor && ((hasNoParams && !isTestNames && !isTestTags) || takesInformer(m))
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1072:  Old style method names will have (Informer) at the end still, but new ones will
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1250:   * This method takes a <code>Filter</code>, which encapsulates an optional <code>Set</code> of tag names that should be included
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1258:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. This trait's implementation
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1268:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially run.
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1269:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1278:   * <li><code>testName</code> - the <code>String</code> name of the test to run (which will be one of the names in the <code>testNames</code> <code>Set</code>)</li>
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1311:    val theTestNames = testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1312:    if (theTestNames.size > 0)
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1326:    // by testNames.
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1339:        for ((tn, ignoreTest) <- filter(theTestNames, tags, suiteId)) {
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1675:   * <li>the size of the <code>testNames</code> <code>List</code>, minus the number of tests marked as ignored and
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1694:     countNestedSuiteTests(filter.runnableTestCount(testNames, tags, suiteId), nestedSuites.toList, filter)
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1790:  // and already broke once. In the early days, all funky dollar sign encrusted names coming out of
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1824:    if ((suite.testNames.size == 0) && (suite.nestedSuites.size > 0))
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1879:    // Discover testNames(Informer) because if we didn't it might be confusing when someone
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1880:    // actually wrote a testNames(Informer) method and it was silently ignored.
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1881:    val isTestNames = simpleName == "testNames"
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1886:    (isInstanceMethod, simpleName, firstFour, paramTypes, hasNoParams, isTestNames, isTestTags, isTestDataFor)
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:1892:   For info and test names, the formatted text should have one level shaved off so that the text will
./.ensime_cache/dep-src/source-jars/org/scalatest/Suite.scala:2430:        Map() ++ theSuite.testNames.map(tn => (tn, suiteTags.toSet))
./.ensime_cache/dep-src/source-jars/org/scalatest/SuiteMixin.scala:154:  * A <code>Set</code> of test names. If this <code>Suite</code> contains no tests, this method returns an empty <code>Set</code>.
./.ensime_cache/dep-src/source-jars/org/scalatest/SuiteMixin.scala:158:  * test names in a well-defined order, the contract of this method does not required a defined order. Subclasses are free to
./.ensime_cache/dep-src/source-jars/org/scalatest/SuiteMixin.scala:159:  * implement this method and return test names in either a defined or undefined order.
./.ensime_cache/dep-src/source-jars/org/scalatest/SuiteMixin.scala:162:  def testNames: Set[String]
./.ensime_cache/dep-src/source-jars/org/scalatest/SuiteMixin.scala:171:   * A <code>Map</code> whose keys are <code>String</code> names of tagged tests and
./.ensime_cache/dep-src/source-jars/org/scalatest/SuiteMixin.scala:172:   * whose associated values are the <code>Set</code> of tag names for the test. If a test has no associated tags, its name
./.ensime_cache/dep-src/source-jars/org/scalatest/TestData.scala:59: * The above <code>FreeSpec</code> contains two tests, both nested inside the same two scopes. The outermost scope names
./.ensime_cache/dep-src/source-jars/org/scalatest/TestData.scala:70: * Therefore, the names of these two tests are:
./.ensime_cache/dep-src/source-jars/org/scalatest/TestData.scala:131:   * Tag names for this test.
./.ensime_cache/dep-src/source-jars/org/scalatest/testng/TestNGSuiteLike.scala:93:   * @param   groupsToInclude    contains the names of groups to run. only tests in these groups will be executed
./.ensime_cache/dep-src/source-jars/org/scalatest/testng/TestNGWrapperSuite.scala:30: * names of TestNG XML config file names to run. Here's an example:
./.ensime_cache/dep-src/source-jars/org/scalatest/testng/TestNGWrapperSuite.scala:51:class TestNGWrapperSuite(xmlSuiteFilenames: List[String]) extends TestNGSuite {
./.ensime_cache/dep-src/source-jars/org/scalatest/testng/TestNGWrapperSuite.scala:95:   * @param   groupsToInclude    contains the names of groups to run. only tests in these groups will be executed
./.ensime_cache/dep-src/source-jars/org/scalatest/testng/TestNGWrapperSuite.scala:129:    xmlSuiteFilenames.foreach( { name => 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/DashboardReporter.scala:154:  // it to the summaries/ subdirectory and renames it to a filename
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/DiscoverySuite.scala:23: * names start with the specified path. If wildcard is true, then any accessible suite whose fully
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/DiscoverySuite.scala:37:    for (suiteClassName <- DiscoverySuite.nestedSuiteNames(path, accessibleSuites, wildcard))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/DiscoverySuite.scala:58:  private[scalatest] def nestedSuiteNames(path: String, accessibleSuites: Set[String], wildcard: Boolean): collection.immutable.IndexedSeq[String] =
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Framework.scala:29:import Runner.parseSuiteArgsIntoNameStrings
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Framework.scala:408:              val filteredTestNames = suite.testNames.filter(_.contains(testWildcardSelector.testWildcard))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Framework.scala:409:              val selectorTestTags = Map.empty ++ filteredTestNames.map(_ -> Set(SELECTED_TAG))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Framework.scala:1099:    val membersOnly: List[String] = parseSuiteArgsIntoNameStrings(membersOnlyArgs, "-m")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Framework.scala:1100:    val wildcard: List[String] = parseSuiteArgsIntoNameStrings(wildcardArgs, "-w")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/HtmlReporter.scala:144:            case None => Resources(errorResourceName, Resources("noNameSpecified"))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/JUnitXmlReporter.scala:460:      for (name <- propertyNames(sysprops))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/JUnitXmlReporter.scala:469:  // Returns a list of the names of properties in a Properties object.
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/JUnitXmlReporter.scala:471:  private def propertyNames(props: Properties): List[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/JUnitXmlReporter.scala:474:    val enumeration = props.propertyNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:59:  // testNames array.  Otherwise the suite id and test name are
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:64:    val testNamesArray = testName match {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:69:    val classNameStr = className.getOrElse("unknown")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:71:    val (testNames, nestedSuites) =
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:72:      if (suiteId == classNameStr)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:73:        (testNamesArray, Array.empty[NestedSuiteParam])
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:76:          NestedSuiteParam(suiteId, testNamesArray, Array())
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Memento.scala:81:    SuiteParam(classNameStr, testNames, Array(), nestedSuites)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:130:private[tools] case class NestedSuiteParam(suiteId: String, testNames: Array[String], wildcardTestNames: Array[String])
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:134:private[tools] case class SuiteParam(className: String, testNames: Array[String], wildcardTestNames: Array[String], nestedSuites: Array[NestedSuiteParam])
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:190: * <tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><code>-Q</code></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center">discover only classes whose names end with <code>Spec</code> or <code>Suite</code><br/>(or other suffixes specified by <code>-q</code>)</td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><code>-Q</code></td></tr>
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:198: * <tr><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><code>-z <em>&lt;test name substring&gt;</em></code></td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><a href="#selectingSuitesAndTests">select tests</a> whose names include the specified substring</td><td style="border-width: 1px; padding: 3px; border: 1px solid black; text-align: center"><code>-z "popped"</code></td></tr>
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:248: * A runpath is the list of filenames, directory paths, and/or URLs that <code>Runner</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:310: * Reporter classes must be specified with fully qualified names. 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:467: * You can specify tag names of tests to include or exclude from a run. To specify tags to include,
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:468: * use <code>-n</code> followed by a white-space-separated list of tag names to include, surrounded by
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:471: * list of tag names to exclude, surrounded by double quotes. (As before, the double quotes are not needed
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:492: * You can specify suffixes of <code>Suite</code> names to discover. To specify suffixes to discover,
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:497: * If suffixes is specified, then only those Suites whose class names end in one of the specified suffixes
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:515: * Specifying suffixes can speed up the discovery process because class files with names not ending the specified suffixes
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:553: * <code>Suite</code> classes must be specified with fully qualified names. 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:577: * If you specify <code>Suite</code> path names with <code>-m</code> or <code>-w</code>, <code>Runner</code> will automatically
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:675: * The <code>-t</code> argument can be used directly by users, but because descriptive test names are usually rather long, the <code>-z</code> argument (described next), will
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:684: * tests whose name includes the substring <code>"popped"</code>, and not select any tests whose names don't include <code>"popped"</code>. This simplified
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:686: * reliably on different operating systems.  Like <code>-t</code>, if <code>-z</code> follows <code>-s</code> or <code>-i</code>, then it only applies to the Suite specified.  Otherwise discovery is performed to find all Suites containing test names that include the substring.
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:928:    val junitsList: List[String] = parseSuiteArgsIntoNameStrings(junitArgs, "-j")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:935:    val membersOnlyList: List[String] = parseSuiteArgsIntoNameStrings(membersOnlyArgs, "-m")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:936:    val wildcardList: List[String] = parseSuiteArgsIntoNameStrings(wildcardArgs, "-w")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:937:    val testNGList: List[String] = parseSuiteArgsIntoNameStrings(testNGArgs, "-b")
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:1178:  // matches class names that end with one of the specified suffixes.
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:1917:  private[scalatest] def parseSuiteArgsIntoNameStrings(args: List[String], dashArg: String) = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2011:          val (testNames, wildcardTestNames) = 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2013:              val testNamesBuffer = new ListBuffer[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2014:              val wildcardTestNamesBuffer = new ListBuffer[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2018:                  testNamesBuffer += it.next
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2020:                  wildcardTestNamesBuffer += it.next
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2022:              (testNamesBuffer.toArray, wildcardTestNamesBuffer.toArray)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2034:                val suiteIdTestNamesBuffer = new ListBuffer[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2035:                val suiteIdWildcardTestNamesBuffer = new ListBuffer[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2040:                    suiteIdTestNamesBuffer += it.next
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2042:                    suiteIdWildcardTestNamesBuffer += it.next
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2044:                nestedLb += new NestedSuiteParam(suiteId, suiteIdTestNamesBuffer.toArray, suiteIdWildcardTestNamesBuffer.toArray)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2051:          lb += SuiteParam(argVal, testNames, wildcardTestNames, nestedSuites)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2063:  // file names.
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2383:          discoverSuiteNames(runpath, loader, suffixes)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2442:            val names = for (suiteParam <- unrunnableList) yield " " + suiteParam.className
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2443:            dispatch(RunAborted(tracker.nextOrdinal(), Resources("nonSuite") + names.mkString(", "), None))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2613:  private[tools] def readMemoryFiles(fileNames: List[String],
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2620:        fileName <- fileNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2655:    if (suiteParam.testNames.length == 0 && suiteParam.wildcardTestNames.length == 0 && suiteParam.nestedSuites.length == 0)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2660:      val (selectSuiteList, selectTestList) = nestedSuites.partition(ns => ns.testNames.length == 0 || ns.wildcardTestNames.length == 0)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2664:        if (suiteParam.testNames.length > 0) 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2665:          Map(suiteInstance.suiteId -> (Map() ++ suiteParam.testNames.map(tn => (tn -> Set(SELECTED_TAG)))))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2670:        if (suiteParam.wildcardTestNames.length > 0) {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2671:          val wildcardTestNames = suiteParam.wildcardTestNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2672:          val allTestNames = suiteInstance.testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2673:          val wildcardTestTags = Map() ++ allTestNames.filter(tn => wildcardTestNames.find(wc => tn.contains(wc)).isDefined)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2680:      def getNestedSuiteSelectedTestNames(nestedSuite: NestedSuiteParam): Array[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2681:        if (nestedSuite.wildcardTestNames.length == 0)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2682:          nestedSuite.testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2684:          val wildcardTestNames = nestedSuite.wildcardTestNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2685:          val allTestNames = suiteInstance.testNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2686:          nestedSuite.testNames ++ allTestNames.filter(tn => wildcardTestNames.find(wc => tn.contains(wc)).isDefined)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2691:        = Map() ++ selectTestList.map(ns => (ns.suiteId -> (Map() ++ getNestedSuiteSelectedTestNames(ns).map(tn => (tn, Set(SELECTED_TAG))))))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/Runner.scala:2699:      val excludeNestedSuites = suiteParam.testNames.length > 0 && nestedSuites.length == 0
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:194: * To specify suites using <a href="Runner$.html#membersOnlyWildcard">members-only or wildcard</a> package names, use
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:223: * to specify that only classes whose names end in one of the specified <a href="Runner$.html#specifyingSuffixesToDiscover">suffixes</a>
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:489:      suite.getTestNames.foreach { tn => 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:500:        ns.getTestNames.foreach { tn => 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:1050:    private val testNamesBuffer = new ListBuffer[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:1058:      testNamesBuffer += test.getName
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:1066:    def getTestNames = testNamesBuffer.toArray
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:1088:    private val testNamesBuffer = new ListBuffer[String]()
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:1095:      testNamesBuffer += test.getName
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestAntTask.scala:1099:    def getTestNames = testNamesBuffer.toArray
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestFramework.scala:21:import org.scalatest.tools.Runner.parseSuiteArgsIntoNameStrings
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestFramework.scala:195:          membersOnly.getAndSet(Some(parseSuiteArgsIntoNameStrings(membersOnlyArgs, "-m")))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/ScalaTestFramework.scala:196:          wildcard.getAndSet(Some(parseSuiteArgsIntoNameStrings(wildcardArgs, "-w")))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/StringReporter.scala:905:        case None => Resources(errorResourceName, Resources("noNameSpecified") + ": " + message)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/StringReporter.scala:934:    // text for test names actually goes over to the left once in a sense, to make room for the icon. So if the indentation
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:53:      val names: Set[String] =
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:64:          names.intersect(suiteInstance.testNames)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:68:            suiteInstance.testNames.exists(_.contains(substring)))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:81:  def discoverSuiteNames(runpath: List[String], loader: ClassLoader,
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:132:              case Some(jf) => processFileNames(getFileNamesIteratorFromJar(jf), '/', loader, suffixes)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:137:            processFileNames(getFileNamesSetFromFile(new File(path), fileSeparator).iterator, fileSeparator, loader, suffixes)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:154:  // (Typically we compose file names using ':' instead of '/', but
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:243:    if (classNameSuffixOkay(className, suffixes) && isDiscoverableSuite(className, loader)
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:256:  // Users may specify that only classes whose names end with
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:259:  private def classNameSuffixOkay(className: String,
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:267:  // Scans specified files and returns names of classes to
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:270:  // Extracts class names from the file names of .class files
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:274:  private def processFileNames(fileNames: Iterator[String], fileSeparator: Char, loader: ClassLoader,
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:278:      for (className <- extractClassNames(fileNames, fileSeparator))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:281:    val classNames = 
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:285:    Set[String]() ++ classNames
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:288:  private def getFileNamesSetFromFile(file: File, fileSeparator: Char): Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:317:  private def getFileNamesIteratorFromJar(file: JarFile): Iterator[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:328:  // Given a fileNames iterator, returns an iterator of class names
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:331:  private def extractClassNames(fileNames: Iterator[String], fileSeparator: Char): Iterator[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/SuiteDiscoveryHelper.scala:333:      for (fileName <- fileNames) yield
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/XmlReporter.scala:433:      for (name <- propertyNames(sysprops))
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/XmlReporter.scala:442:  // Returns a list of the names of properties in a Properties object.
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/XmlReporter.scala:444:  private def propertyNames(props: Properties): List[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/tools/XmlReporter.scala:447:    val enumeration = props.propertyNames
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:107:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:130:   * for <code>testNames</code> for an example.) The resulting test name must not have been registered previously on
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:916:   * A <code>Map</code> whose keys are <code>String</code> names of tagged tests and whose associated values are
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:936:   * for <code>testNames</code> for an example.)
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:983:   * This method takes a <code>Set</code> of tag names that should be included (<code>tagsToInclude</code>), and a <code>Set</code>
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:990:   * determine which of the tests named in the <code>testNames</code> <code>Set</code> should be run. For more information on trait tags, see the main documentation for this trait.
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:995:   * invokes <code>testNames</code> on this <code>Suite</code> to get a <code>Set</code> of names of tests to potentially execute.
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:996:   * (A <code>testNames</code> value of <code>None</code> essentially acts as a wildcard that means all tests in
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1005:   * <li><code>testName</code> - the <code>String</code> name of the test to run (which will be one of the names in the <code>testNames</code> <code>Set</code>)</li>
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1025:   * An immutable <code>Set</code> of test names. If this <code>WordSpec</code> contains no tests, this method returns an
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1029:   * This trait's implementation of this method will return a set that contains the names of all registered tests. The set's
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1030:   * iterator will return those names in the order in which the tests were registered. Each test's name is composed
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1051:   * Invoking <code>testNames</code> on this <code>WordSpec</code> will yield a set that contains the following
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1060:  override def testNames: Set[String] = {
./.ensime_cache/dep-src/source-jars/org/scalatest/WordSpecLike.scala:1062:    ListSet(atomic.get.testNamesList.toArray: _*)
./.ensime_cache/dep-src/source-jars/scala/collection/immutable/package.scala:14:   *  should not have public API traits with seductive names like
./.ensime_cache/dep-src/source-jars/scala/collection/immutable/StringLike.scala:216:   *  with group names g1 through gn.
./.ensime_cache/dep-src/source-jars/scala/collection/immutable/StringLike.scala:222:   *  @param groupNames The names of the groups in the pattern, in the order they appear.
./.ensime_cache/dep-src/source-jars/scala/collection/immutable/StringLike.scala:224:  def r(groupNames: String*): Regex = new Regex(toString, groupNames: _*)
./.ensime_cache/dep-src/source-jars/scala/concurrent/duration/Duration.scala:93:    timeUnitLabels flatMap { case (unit, names) => expandLabels(names) map (_ -> unit) } toMap
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:59:  @deprecated("Names should be specified individually or discovered via reflection", "2.10.0")
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:60:  def this(initial: Int, names: String*) = {
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:62:    this.nextName = names.iterator
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:64:  @deprecated("Names should be specified individually or discovered via reflection", "2.10.0")
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:65:  def this(names: String*) = this(0, names: _*)
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:86:    * names. */
./.ensime_cache/dep-src/source-jars/scala/Enumeration.scala:125:   *  the argument `s`.  The names are determined automatically via reflection.
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/QuasiquoteCompat.scala:748:    private def selectScala(names: Name*)                      = names.tail.foldLeft(ScalaDot(names.head).asInstanceOf[u.Tree]) { Select(_, _) }
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/QuasiquoteCompat.scala:749:    private def callScala(names: Name*)(args: List[Tree])      = Apply(selectScala(names: _*), args)
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:10:  import global.{definitions => _, nme => _, tpnme => _, lowerTermNames => _, copyValDef => _, deriveTemplate => _, _}
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:969:   *  All names in selectors are TermNames despite the fact ImportSelector
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:970:   *  can theoretically contain TypeNames too (but they never do in practice.)
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:983:    private object NameSelector {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:994:    private object RenameSelector {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1027:    private object NameSelectorRepr {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1046:    private object RenameSelectorRepr {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1048:        val left = NameSelectorRepr(name1, pos1)
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1049:        val right = NameSelectorRepr(name2, pos2)
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1053:        case Arrow(NameSelectorRepr(name1, pos1), NameSelectorRepr(name2, pos2)) =>
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1063:        atPos(pos)(Arrow(NameSelectorRepr(name, pos), WildcardSelectorRepr(pos)))
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1065:        case Arrow(NameSelectorRepr(name, pos), WildcardSelectorRepr(_)) =>
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1081:        case NameSelectorRepr(name, pos)                  => NameSelector(name, derivedOffset(pos))
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1082:        case RenameSelectorRepr(name1, pos1, name2, pos2) => RenameSelector(name1, derivedOffset(pos1), name2, derivedOffset(pos2))
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1092:        case NameSelector(name, offset)                     => NameSelectorRepr(name, derivedPos(imp, offset))
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/ReificationSupport.scala:1093:        case RenameSelector(name1, offset1, name2, offset2) => RenameSelectorRepr(name1, derivedPos(imp, offset1), name2, derivedPos(imp, offset2))
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/SymbolTableCompat.scala:20:    import global.{nameToNameOps => _, definitions => _, nme => _, tpnme => _, lowerTermNames => _, _}
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/SymbolTableCompat.scala:265:    // Extractor that matches names which were generated by some
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/SymbolTableCompat.scala:347:  trait CommonNames {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/SymbolTableCompat.scala:360:  trait KeywordNames {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/SymbolTableCompat.scala:368:  object nme extends CommonNames with KeywordNames {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/SymbolTableCompat.scala:440:  object tpnme extends CommonNames {
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/TreeGen.scala:12:  import global.{nme => _, tpnme => _, lowerTermNames => _, copyValDef => _, _}
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/TreeGen.scala:820:  /** Traverse pattern and collect all variable names with their types in buffer
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/TreeGen.scala:920:  /** Translate names in Select/Ident nodes to type names.
./.ensime_cache/dep-src/source-jars/scala/quasiquotes/TreeInfo.scala:352:   * is a not a variable pattern; if only binds names.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Annotations.scala:29: *  following the type-checker. Arguments in `javaArgs` are repesented as a map from [[scala.reflect.api.Names#Name]] to
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Annotations.scala:35: *  For more information about `Annotation`s, see the [[http://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html Reflection Guide: Annotations, Names, Scopes, and More]]
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Importers.scala:24: *  Since importers match `Symbol` tables of the source and the target `Universe`s using plain string names,
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Mirrors.scala:20: * <li>'''“Classloader” mirrors'''. These mirrors translate names to symbols
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Mirrors.scala:65: * of type [[scala.reflect.api.Mirrors#ReflectiveMirror]], which can load symbols by names as
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:9: *  Names are simple wrappers for strings. [[scala.reflect.api.Names#Name Name]] has two subtypes
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:10: *  [[scala.reflect.api.Names#TermName TermName]] and [[scala.reflect.api.Names#TypeName TypeName]]
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:11: *  which distinguish names of terms (like objects or members) and types. A term and a type of the
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:23: *  For more information about creating and using `Name`s, see the [[http://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html Reflection Guide: Annotations, Names, Scopes, and More]]
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:28:trait Names {
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:31:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:37:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:41:  /** The abstract type of names.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:42:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:52:  /** The abstract type of names representing terms.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:53:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:63:  /** The abstract type of names representing types.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:64:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:90:    /** Replaces all occurrences of \$op_names in this name by corresponding operator symbols.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:95:    /** Replaces all occurrences of operator symbols in this name by corresponding \$op_names.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:110:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Names.scala:115:   *  @group Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Position.scala:14: * For more information about `Position`s, see the [[http://docs.scala-lang.org/overviews/reflection/annotations-names-scopes.html Reflection Guide: Annotations, Names, Scopes, and More]]
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Printers.scala:43: * the case. Symbols aren't fully represented (only their names are). Thus, this method
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Scopes.scala:9: * A scope object generally maps names to symbols available in a corresponding lexical scope.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:16: *  Standard names are names that are essential to creating trees or to reflecting Scala artifacts.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:19: *  These standard names can be referred to using [[nme `nme`]] for term names and [[tpnme `tpnme`]] for type names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:21: *  @see [[Names]]
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:23: *  The API for names in Scala reflection.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:24: *  @groupname StandardNames Standard Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:27:trait StandardNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:30:  /** A value containing all [[TermNamesApi standard term names]].
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:31:   *  @group StandardNames
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:33:  val nme: TermNamesApi
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:35:  /** A value containing all [[TypeNamesApi standard type names]].
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:36:   *  @group StandardNames
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:38:  val tpnme: TypeNamesApi
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:40:  /** Defines standard names, common for term and type names: These can be accessed via the [[nme]] and [[tpnme]] members.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:43:  trait NamesApi {
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:70:  /** Defines standard term names that can be accessed via the [[nme]] member.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:73:  trait TermNamesApi extends NamesApi {
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:88:     *  `LOCAL_SUFFIX_STRING` is appended to the names of local identifiers,
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:95:  /** Defines standard type names that can be accessed via the [[tpnme]] member.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/StandardNames.scala:98:  trait TypeNamesApi extends NamesApi {
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Symbols.scala:212:     *  Type name namespaces do not intersect with term name namespaces.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Symbols.scala:213:     *  This fact is reflected in different types for names of `TermSymbol` and `TypeSymbol`.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Symbols.scala:223:    /** The encoded full path name of this symbol, where outer names and inner names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Symbols.scala:605:    /** Term symbols have their names of type `TermName`.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Symbols.scala:725:    /** Type symbols have their names of type `TypeName`.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Trees.scala:527:    def name: Name // can't be a TermName because macros can be type names.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Trees.scala:764:    /** Label's parameters - names that can be used in the body of the label.
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Trees.scala:858:   *  Selectors are a list of ImportSelectors, which conceptually are pairs of names (from, to).
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Trees.scala:2556:   *  The string `name` argument is assumed to represent a [[scala.reflect.api.Names#TermName `TermName`]].
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Universe.scala:23: *   - [[scala.reflect.api.Names#Name Names]] represent term and type names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Universe.scala:63:                           with Names
./.ensime_cache/dep-src/source-jars/scala/reflect/api/Universe.scala:72:                           with StandardNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Definitions.scala:331:    // Modules whose members are in the default namespace
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Definitions.scala:1233:      def flatNameString(sym: Symbol, separator: Char): String =
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Definitions.scala:1236:        else flatNameString(sym.owner, separator) + nme.NAME_JOIN_STRING + sym.simpleName
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Definitions.scala:1240:        else "L" + flatNameString(etp.typeSymbol, '/') + ";"
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Definitions.scala:1244:      else flatNameString(etp.typeSymbol, '.')
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Mirrors.scala:58:     *  loads unqualified names from the root package.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Mirrors.scala:67:     *  loads unqualified names from the empty package.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:13:trait LowPriorityNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:14:  self: Names =>
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:19:/** The class Names ...
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:24:trait Names extends api.Names with LowPriorityNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:25:  implicit def promoteTermNamesAsNecessary(name: Name): TermName = name.toTermName
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:35:  /** Memory to store all names sequentially. */
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:39:  /** Hashtable for finding term names quickly. */
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:42:  /** Hashtable for finding type names quickly. */
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:144:   *  TODO - resolve schizophrenia regarding whether to treat Names as Strings
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:145:   *  or Strings as Names.  Give names the key functions the absence of which
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Names.scala:173:    def bothNames: List[Name] = List(toTermName, toTypeName)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Printers.scala:360:          print("<apply-dynamic>(", qual, "#", tree.symbol.nameString)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:16:trait StdNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:21:  implicit def lowerTermNames(n: TermName): String = n.toString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:23:  /** Tensions: would like the keywords to be the very first names entered into the names
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:27:   *  keywords must run first. If it's the top in the superclass chain, then CommonNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:28:   *  must inherit from it, which means TypeNames would inherit keywords as well.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:30:   *  Solution: Keywords extends CommonNames and uses early defs to beat the
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:31:   *  CommonNames constructor out of the starting gate.  This is its builder.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:86:  abstract class CommonNames extends NamesApi {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:125:    final val ScalaValueNames: scala.List[NameType] =
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:147:  // abstract class Keywords extends CommonNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:205:  } with CommonNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:209:  abstract class TypeNames extends Keywords with TypeNamesApi {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:245:    // Annotation simple names, used in Namer
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:275:  abstract class TermNames extends Keywords with TermNamesApi {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:278:    /** Base strings from which synthetic names are derived. */
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:298:    // Compiler internal names
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:583:    // Compiler utilized names
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:836:    // ASCII names for operators
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:868:    val CommonOpNames   = Set[Name](OR, XOR, AND, EQ, NE)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:869:    val ConversionNames = Set[Name](toByte, toChar, toDouble, toFloat, toInt, toLong, toShort)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:870:    val BooleanOpNames  = Set[Name](ZOR, ZAND, UNARY_!) ++ CommonOpNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:871:    val NumberOpNames   = (
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:874:      ++ ConversionNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:875:      ++ CommonOpNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:957:    /** Translate a String into a list of simple TypeNames and TermNames.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1001:  object tpnme extends TypeNames { }
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1003:  /** For fully qualified type names.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1005:  object fulltpnme extends TypeNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1011:  /** Java binary names, like scala/runtime/Nothing$.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1022:  object nme extends TermNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1045:    private val reflectionCacheNames = Set[NameType](
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1052:    def isReflectionCacheName(name: Name) = reflectionCacheNames exists (name startsWith _)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1060:  abstract class SymbolNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1151:  private abstract class JavaNames extends SymbolNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1193:  private class MSILNames extends SymbolNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1232:  private class J2SENames extends JavaNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1238:  lazy val sn: SymbolNames =
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1239:    if (forMSIL) new MSILNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/StdNames.scala:1240:    else new J2SENames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:121:    // TODO - don't allow names to be renamed in this unstructured a fashion.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:122:    // Rename as little as possible.  Enforce invariants on all renames.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:334:     *  Calling this method multiple times will re-use the same parameter names.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:674:    def isInDefaultNamespace = UnqualifiedOwners(effectiveOwner)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:1030:    /** The encoded full path name of this symbol, where outer names and inner names
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:1049:    /** The encoded full path name of this symbol, where outer names and inner names
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:1776:      val primaryNames = constrParamAccessors.map(acc => nme.dropLocalSuffix(acc.name))
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:1778:        primaryNames indexWhere { orig =>
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2326:    def nameString: String = (
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2333:    def fullNameString: String = {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2335:        if (sym.isRootSymbol || sym == NoSymbol) sym.nameString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2336:        else if (sym.owner.isEffectiveRoot) sym.nameString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2337:        else recur(sym.effectiveOwner.enclClass) + "." + sym.nameString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2351:      if (hasMeaninglessName) owner.decodedName + idString else nameString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2400:      varianceString + nameString + infoString + flagsExplanationString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2488:    // TODO - rescue CAPTURED from BYNAMEPARAM so we can see all the names.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2741:    // TODO - don't allow names to be renamed in this unstructured a fashion.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2742:    // Rename as little as possible.  Enforce invariants on all renames.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2896:    override def nameString: String =
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2897:      if (settings.debug.value) (super.nameString + "&" + level)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Symbols.scala:2898:      else super.nameString
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/SymbolTable.scala:15:                              with Names
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/SymbolTable.scala:28:                              with StdNames
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/SymbolTable.scala:91:  // For too long have we suffered in order to sort NAMES.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/SymbolTable.scala:94:  implicit def lowPriorityNameOrdering[T <: Names#Name]: Ordering[T] =
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/SymbolTable.scala:97:  private object SimpleNameOrdering extends Ordering[Names#Name] {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/SymbolTable.scala:98:    def compare(n1: Names#Name, n2: Names#Name) = (
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/TreeInfo.scala:277:   * is a not a variable pattern; if only binds names.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:1445:      if (settings.debug.value) sym.nameString + ".this."
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:1448:      else if (sym.isModuleClass) sym.fullNameString + "."
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:1449:      else sym.nameString + ".this."
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:1515:      else pre.prefixString + sym.nameString + "."
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:2123:    override def prefixString = if (sym.isOmittablePrefix) "" else prefix.prefixString + sym.nameString + "."
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:2514:      else finishPrefix(preString + sym.nameString + argsString)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:3478:  case class DeBruijnBinder(pnames: List[Name], ptypes: List[Type], restpe: Type) extends Type {
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:3480:      val kind = if (pnames.head.isTypeName) "poly" else "method"
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:3481:      "De Bruijn "+kind+"("+(pnames mkString ",")+";"+(ptypes mkString ",")+";"+restpe+")"
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:3916:      case DeBruijnBinder(pnames, ptypes, restpe) =>
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:3917:        val isType = pnames.head.isTypeName
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:3918:        val newParams = for (name <- pnames) yield
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:4604:                    /** Relaxed version of instParams which matches on names not symbols.
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:5148:          throw new MalformedType(pre, sym.nameString)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/Types.scala:5387:   *  sym1 and sym2 are two existential skolems with equal names and bounds,
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/util/TableDef.scala:36:  def colNames = cols map (_.name)
./.ensime_cache/dep-src/source-jars/scala/reflect/internal/util/TableDef.scala:55:      headFormat.format(colNames: _*),
./.ensime_cache/dep-src/source-jars/scala/reflect/macros/Context.scala:32:                 with Names
./.ensime_cache/dep-src/source-jars/scala/reflect/macros/runtime/Context.scala:9:                         with Names
./.ensime_cache/dep-src/source-jars/scala/reflect/NameTransformer.scala:12:/** Provides functions to encode and decode Scala symbolic names.
./.ensime_cache/dep-src/source-jars/scala/reflect/reify/codegen/GenNames.scala:4:trait GenNames {
./.ensime_cache/dep-src/source-jars/scala/reflect/reify/codegen/GenSymbols.scala:47:       *  packageless packages and packageless objects with the same names in the same program.
./.ensime_cache/dep-src/source-jars/scala/reflect/reify/codegen/GenSymbols.scala:62:       *    // staticXXX methods always look into parent packages and ignores parent modules, so for fully qualified names they are non-ambiguous
./.ensime_cache/dep-src/source-jars/scala/reflect/reify/codegen/GenSymbols.scala:81:        if (reifyDebug) println("Locatable: %s (%s) owned by %s (%s) at %s".format(sym, sym.accurateKindString, sym.owner, sym.owner.accurateKindString, sym.owner.fullNameString))
./.ensime_cache/dep-src/source-jars/scala/reflect/reify/phases/Reify.scala:10:               with GenNames
./.ensime_cache/dep-src/source-jars/scala/reflect/reify/utils/SymbolTables.scala:62:    def --(names: Iterable[TermName]): SymbolTable = (this /: names)((symtab, name) => symtab.remove(name))
./.ensime_cache/dep-src/source-jars/scala/reflect/runtime/JavaMirrors.scala:963:            // otherwise we may mistake mangled symbolic names for mangled nested names
./.ensime_cache/dep-src/source-jars/scala/reflect/runtime/SynchronizedOps.scala:9:// Names
./.ensime_cache/dep-src/source-jars/scala/sys/ShutdownHookThread.scala:28:  /** Creates, names, and registers a shutdown hook to run the
./.ensime_cache/dep-src/source-jars/scala/tools/ant/Same.scala:116:    val originNames: Array[String] = getDirectoryScanner(origin.get).getIncludedFiles
./.ensime_cache/dep-src/source-jars/scala/tools/ant/Same.scala:121:      originName: String <- originNames;
./.ensime_cache/dep-src/source-jars/scala/tools/ant/Scalac.scala:418:   *  `'''true'''`, the scalac ant task will print out the filenames
./.ensime_cache/dep-src/source-jars/scala/tools/ant/Scaladoc.scala:450:   *  @param input A colon-delimited list of fully qualified package names that will be skipped from scaladoc.
./.ensime_cache/dep-src/source-jars/scala/tools/cmd/gen/AnyVals.scala:191:     *  @param    ops       list of function names e.g. List(">>", "%")
./.ensime_cache/dep-src/source-jars/scala/tools/cmd/Opt.scala:38:    /** Names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/DocComments.scala:491:        val partnames = (parts.init map newTermName) :+ newTypeName(parts.last)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/DocComments.scala:493:          case "this" :: _      => (site.thisType, partnames.tail)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/DocComments.scala:495:            site.ownerChain.find(_.name == partnames.head) match {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/DocComments.scala:496:              case Some(clazz)  => (clazz.thisType, partnames drop 2)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/DocComments.scala:500:            (getSite(partnames.head), partnames.tail)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Parsers.scala:257:  // through definitions to obtain the names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Parsers.scala:258:  lazy val ScalaValueClassNames = Seq(tpnme.AnyVal,
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Parsers.scala:302:    private lazy val primitiveNames: Set[Name] = tpnme.ScalaValueNames.toSet
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Parsers.scala:306:    private def isPrimitiveType(name: Name) = inScalaRootPackage && primitiveNames(name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Parsers.scala:981:    /** Assumed (provisionally) to be TermNames. */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Parsers.scala:2836:        if (inScalaRootPackage && ScalaValueClassNames.contains(name))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Scanners.scala:14:import scala.xml.Utility.{ isNameStart }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Scanners.scala:36:    val names = keywords sortBy (_._1.start) map { case (k, v) => (k.start, v) }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Scanners.scala:37:    val low   = names.head._1
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Scanners.scala:38:    val high  = names.last._1
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Scanners.scala:41:    names foreach { case (k, v) => arr(k + low) = v }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/Scanners.scala:370:              case ' ' | '\t' | '\n' | '{' | '(' | '>' if isNameStart(ch) || ch == '!' || ch == '?' =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:33:  private object xmltypes extends TypeNames {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:39:    val _NamespaceBinding: NameType    = "NamespaceBinding"
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:48:  private object xmlterms extends TermNames {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:60:  import xmltypes.{_Comment, _Elem, _EntityRef, _Group, _MetaData, _NamespaceBinding, _NodeBuffer,
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:78:  private def _scala_xml_NamespaceBinding   = _scala_xml(_NamespaceBinding)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:185:    def handleNamespaceBinding(pre: String, z: String): Tree = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:188:        New(_scala_xml_NamespaceBinding, LL(const(pre), t, Ident(_tmpscope)))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:200:    /** Extract all the namespaces from the attribute map. */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:201:    val namespaces: List[Tree] =
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:207:        handleNamespaceBinding(ns, z)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:235:    lazy val scopeDef     = ValDef(NoMods, _scope, _scala_xml_NamespaceBinding, Ident(_tmpscope))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:236:    lazy val tmpScopeDef  = ValDef(Modifiers(MUTABLE), _tmpscope, _scala_xml_NamespaceBinding, Ident(_scope))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:241:      (attributes.isEmpty, namespaces.isEmpty) match {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:243:        case (true , false)   => (scopeDef :: Nil, tmpScopeDef :: namespaces)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/SymbolicXMLBuilder.scala:245:        case (false, false)   => (scopeDef :: metadataDef :: attributes, tmpScopeDef :: namespaces)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/parser/TreeBuilder.scala:71:  /** Traverse pattern and collect all variable names with their types in buffer
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/TreeDSL.scala:264:      def ARGNAMES = ARGS map Ident
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ast/TreeGen.scala:289:  /** Translate names in Select/Ident nodes to type names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/icode/analysis/TypeFlowAnalysis.scala:68:   *  names to types and a type stack.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/icode/ExceptionHandlers.scala:15: * pattern matching instead of just class names to identify handlers,
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/icode/GenICode.scala:1797:     *  label names, the bind to the outer labeldef will be lost! That's because
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/icode/Printers.scala:73:      print(f.symbol.nameString); print(": ");
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:56:              case names =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:57:                log("No Main-Class due to multiple entry points:\n  " + names.mkString("\n  "))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:88:          log(s"Optimizer eliminated ${sym.fullNameString}")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:164:  // unlike javaNameCache, reverseJavaName contains entries only for class symbols and their internal names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:259:  // finding the least upper bound in agreement with the bytecode verifier (given two internal names handed by ASM)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:433:     * @param interfaces the internal names of the class's interfaces (see
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:474:    // Getters for (JVMS 4.2) internal and unqualified names (represented as JType instances).
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:499:    /** Return the name of this symbol that can be used on the Java platform.  It removes spaces from names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:774:     * This method returns such list of internal names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:1037:      // val paramNames     = 0 until paramJavaTypes.length map ("x_" + _)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:1105:      lazy val conflictingNames: Set[Name] = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:1108:      debuglog("Potentially conflicting names for forwarders: " + conflictingNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:1113:        else if (conflictingNames(m.name))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:1544:      // TODO param names: (m.params map (p => javaName(p.sym)))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:1720:    /** Just a namespace for utilities that encapsulate MethodVisitor idioms.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenASM.scala:3114:  /** A namespace for utilities to normalize the code of an IMethod, over and beyond what IMethod.normalize() strives for.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:55:          log(s"Optimizer eliminated ${sym.fullNameString}")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:74:              case names =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:75:                log("No Main-Class due to multiple entry points:\n  " + names.mkString("\n  "))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:981:      val paramNames     = 0 until paramJavaTypes.length map ("x_" + _)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:996:        mkArray(paramNames))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:1037:      lazy val conflictingNames: Set[Name] = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:1040:      debuglog("Potentially conflicting names for forwarders: " + conflictingNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVM.scala:1045:        else if (conflictingNames(m.name))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/jvm/GenJVMUtil.scala:66:     *  platform.  It removes spaces from names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:404:          // TODO: put a SerString (don't know what exactly, names of the enums somehow..)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:564:    var dbFilenameSeen = false
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:588:      dbFilenameSeen = false
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:935:          if(!skip || !dbFilenameSeen) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:936:            val fileName = if(dbFilenameSeen) "" else {dbFilenameSeen = true; ilasmFileName(clasz)};
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:1596:     * platform. It removes spaces from names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:2074:          val paramNames: Array[String] = new Array[String](paramTypes.length)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:2076:            paramNames(i) = "x_" + i
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:2087:            mirrorMethod.DefineParameter(i, ParameterAttributes.None, paramNames(i))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/msil/GenMSIL.scala:2245:              Console.println("While looking up " + mClass + "::" + sym.nameString)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:116:        val sourceNamesComparison = (a.cunit.toString() compare b.cunit.toString())
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:117:        if(sourceNamesComparison != 0) sourceNamesComparison
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:119:          val namesComparison = (a.toString() compare b.toString())
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:120:          if(namesComparison != 0) namesComparison
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:202:      (sym.ownerChain take count filterNot (_.isPackageClass)).reverseMap(_.nameString).mkString(".")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:257:        val namesComparison = (a.toString() compare b.toString())
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:258:        if(namesComparison != 0) namesComparison
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:577:          val callees = inlinedMethodCount.toList map { case (k, v) => k.fullNameString + ( if (v == 1) "" else "/" + v ) }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/backend/opt/Inliners.scala:580:          inlineLog("<<tldr>>", m.symbol.fullName, s"${m.symbol.nameString}: $s1$s2")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/CompilerCommand.scala:36:    |  (partial) phase names, phase ids, phase id ranges, or the string "all".
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/dependencies/Changes.scala:54:  private def sameParameterSymbolNames(sym1: Symbol, sym2: Symbol): Boolean =
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/dependencies/Changes.scala:121:      (tp1.params corresponds tp2.params)((t1, t2) => sameParameterSymbolNames(t1, t2) && sameFlags(t1, t2)) &&
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/comment/Comment.scala:123:  /** Member group names (overriding the short tag) */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/comment/Comment.scala:124:  def groupNames: Map[String,String]
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/CommentFactoryBase.scala:52:    groupNames0:     Map[String,Body] = Map.empty,
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/CommentFactoryBase.scala:89:    val groupNames     = groupNames0 flatMap {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/CommentFactoryBase.scala:372:          groupNames0     = allSymsOneTag(SimpleTagKey("groupname")),
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/MemberLookupBase.scala:36:      |Disambiguating terms and types: Prefix terms with '$' and types with '!' in case both names are in use:
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/MemberLookupBase.scala:69:            def nameString(s: Symbol) = s.nameString + (if ((s.isModule || s.isModuleClass) && !s.isPackage) "$" else "")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/MemberLookupBase.scala:72:            sym.ownerChain.reverse.filterNot(isRoot(_)).map(nameString(_)).mkString(".") + packageSuffix
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/MemberLookupBase.scala:119:    // we have a preference for term names for all terms except for the last, where we prefer a class:
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/base/MemberLookupBase.scala:204:    (sym.nameString + sym.signatureString).replaceAll("\\s", "")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/html/HtmlPage.scala:203:  /** Returns the HTML code that represents the templates in `tpls` as a list of hyperlinked names. */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/html/page/diagram/DotDiagramGenerator.scala:80:        // it seems dot chokes on node names over 8000 chars, so let's limit the size of the string
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/html/page/diagram/DotDiagramGenerator.scala:214:    // escape HTML characters in node names
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/html/SyntaxHigh.scala:20:    * (see [[scala.reflect.internal.StdNames]]) */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/Entity.scala:60:  /** Indicates whether this entity lives in the types namespace (classes, traits, abstract/alias types) */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/Entity.scala:63:  /** Indicates whether this entity lives in the terms namespace (objects, packages, methods, values) */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactory.scala:90:    val name = optimize(sym.nameString)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactory.scala:508:    def groupName(group: String): String = groupSearch(_.groupNames.get(group)) getOrElse { if (group == defaultGroup) defaultGroupName else group }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactory.scala:569:        if (p.nameString contains "$") makeValueParam(p, inTpl, optimize("arg" + i)) else makeValueParam(p, inTpl)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactory.scala:575:    val name = optimize(sym.nameString)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactory.scala:947:    makeValueParam(aSym, inTpl, aSym.nameString)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactory.scala:1045:        path.insert(0, sym1Norm.nameString)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:112:          hardcoded.valueClassFilter(sym.nameString, ic.conversionQualifiedName))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:254:          val typeParamNames = sym.typeParams.map(_.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:259:            case TypeRef(pre, sym, List(TypeRef(NoPrefix, targ, Nil))) if (typeParamNames contains targ.name) =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:263:                    val typeParamName = targ.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:270:                    val typeParamName = targ.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:302:                val typeParamName = tparam.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:307:                val typeParamName = tparam.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:313:                val typeParamName = tparam.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:318:                val typeParamName = tparam.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:376:        Right(convSym.nameString)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:379:    def conversionShortName = convSym.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:391:      debug(sym.nameString + "\n" + "=" * sym.nameString.length())
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryImplicitSupport.scala:586:    (aSym.nameString != "getClass")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryTypeSupport.scala:169:          val name = prefix + bSym.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/model/ModelFactoryTypeSupport.scala:249:                nameBuffer append sym.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/Settings.scala:193:    "A colon-delimited list of fully qualified package names that will be skipped from scaladoc.",
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/Settings.scala:205:    "(deprecated) comma-separated list of package_names=doc_URL for external dependencies, where package names are ':'-separated"
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/Settings.scala:235:  lazy val skipPackageNames =
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/Settings.scala:242:    skipPackageNames(qname.toLowerCase)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/doc/Settings.scala:345:    // included as names as here we don't have access to a Global with Definitions :(
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:377:    def echoFilenames = opt.debug && (opt.verbose || currentRun.size < 5)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:381:    def showNames     = List(showClass, showObject).flatten
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:456:      if (opt.echoFilenames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:729:      analyzer.namerFactory   -> "resolve names, attach symbols to named trees",
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:789:  /** The names of the phases. */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:790:  lazy val phaseNames = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:797:    val width = phaseNames map (_.length) max
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:811:    val width = phaseNames map (_.length) max
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:992:    def packageNames(cp: PlatformClassPath): Set[String] = cp.packages.toSet map getName
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1006:          for (pstr <- packageNames(oldcp) ++ packageNames(newcp)) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1191:    if (opt.debug && !opt.echoFilenames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1503:      opt.showNames foreach (x => showDef(x, opt.declsOnly, globalPhase))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1655:    /** Compile list of files given by their names */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1656:    def compile(filenames: List[String]) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1659:          if (isScriptRun && filenames.size > 1) returning(Nil)(_ => globalError("can only compile one script at a time"))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/Global.scala:1660:          else filenames map getSourceFile
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interactive/tests/Tester.scala:202:    val (_, filenames) = settings.processArguments(args.toList.tail, true)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interactive/tests/Tester.scala:203:    println("filenames = "+filenames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interactive/tests/Tester.scala:204:    val files = filenames.toArray map (str => new BatchSourceFile(AbstractFile.getFile(str)): SourceFile)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/CompletionOutput.scala:67:      def paramNameString(sym: Symbol)  = if (sym.isSynthetic) "" else sym.nameString + ": "
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/CompletionOutput.scala:68:      def paramString(sym: Symbol)      = paramNameString(sym) + typeToString(sym.info.dealiasWiden)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/CompletionOutput.scala:79:      method.keyString + " " + method.nameString + (method.info.normalize match {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:18:import scala.reflect.internal.Names
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:307:        // deadlocks on startup if we try to translate names too early
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:339:  def allDefinedNames = definedNameMap.keys.toList.sorted
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:381:    req.referencedNames foreach (x => referencedNameMap(x) = req)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:387:      name   <- req.definedNames filterNot (x => req.definedNames contains x.companionName)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:398:    req.definedNames foreach { name =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:640:      directlyBoundNames += newTermName(name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:700:    val packageName = sessionNames.line + lineId
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:701:    val readName    = sessionNames.read
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:702:    val evalName    = sessionNames.eval
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:703:    val printName   = sessionNames.print
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:704:    val resultName  = sessionNames.result
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:822:    /** all (public) names defined by these statements */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:823:    val definedNames = handlers flatMap (_.definedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:825:    /** list of names used by this expression */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:826:    val referencedNames: List[Name] = handlers flatMap (_.referencedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:828:    /** def and val names */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:829:    def termNames = handlers flatMap (_.definesTerm)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:830:    def typeNames = handlers flatMap (_.definesType)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:837:    /** Code to import bound names from previous lines - accessPath is code to
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:841:      importsCode(referencedNames.toSet)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:964:      mapFrom[Name, Name, T](termNames ++ typeNames)(x => f(cleanMemberDecl(resultSymbol, x)))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:972:    //   typeNames map (x => x -> afterTyper(resultSymbol.info.nonPrivateDecl(x).tpe)) toMap
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:975:      termNames.map(x => x -> applyToResultMember(x, x => x)) ++
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:976:      typeNames.map(x => x -> compilerTypeOf(x).typeSymbolDirect)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:979:    lazy val typesOfDefinedTerms = mapFrom[Name, Name, Type](termNames)(x => applyToResultMember(x, _.tpe))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:983:      try   { ("" + (lineRep call sessionNames.print), true) }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1022:    prevRequests.toList.reverse filter (_.definedNames contains name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1026:      req.handlers find (_.definedNames contains name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1089:  def definedTerms      = onlyTerms(allDefinedNames) filterNot isInternalTermName
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1090:  def definedTypes      = onlyTypes(allDefinedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1094:  // Terms with user-given names (i.e. not res0 and not synthetic)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1095:  def namedDefinedTerms = definedTerms filterNot (x => isUserVarName("" + x) || directlyBoundNames(x))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1125:  private val directlyBoundNames = mutable.Set[Name]()
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1134:  def allImplicits        = allHandlers filter (_.definesImplicit) flatMap (_.definedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1137:  def visibleTermNames: List[Name] = definedTerms ++ importedTerms distinct
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/IMain.scala:1140:  def unqualifiedIds = visibleTermNames map (_.toString) filterNot (_ contains "$") sorted
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:37:  def allImportedNames = importHandlers flatMap (_.importedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:38:  def importedTerms    = onlyTerms(allImportedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:39:  def importedTypes    = onlyTypes(allImportedNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:96:   * The argument is a set of Names that need to be imported.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:101:   * (2) If it imports any names from a request, it imports all
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:110:     *  useful imports for the specified set of wanted names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:116:        * 'wanted' is the set of names that need to be imported.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:123:          case x                => x.definesImplicit || (x.definedNames exists wanted)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:131:            val newWanted = wanted ++ referencedNames -- definedNames -- importedNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:161:          if (x.importsWildcard || currentImps.exists(x.importedNames contains _))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:168:          else currentImps ++= x.importedNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Imports.scala:176:          for (imv <- x.definedNames) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:60:    def memberNames   = members map tos
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:61:    def methodNames   = methods map tos
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:62:    def packageNames  = packages map tos
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:63:    def aliasNames    = aliases map tos
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:111:    def excludeNames: List[String] = (anyref.methodNames filterNot anyRefMethodsToShow) :+ "_root_"
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:119:      (excludeNames contains name) ||
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:126:      debugging(tp + " completions ==> ")(filtered(memberNames))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:142:    override def excludeNames = anyref.methodNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:147:      case 0    => filtered(memberNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:148:      case _    => memberNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:219:    override def excludeNames       = anyref.methodNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:239:      case 0    => filtered(packageNames ++ aliasNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/JLineCompletion.scala:249:      case 0    => filtered(packageNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:33:   *  that need to be imported.  It might return extra names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:91:    lazy val referencedNames = ImportVarsTraverser(member)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:92:    def importedNames        = List[Name]()
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:93:    def definedNames         = definesTerm.toList ++ definesType.toList
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:94:    def definedOrImported    = definedNames ++ importedNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:101:    override def toString = shortName + referencedNames.mkString(" (refs: ", ", ", ")")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:199:    private def selectorRenames = selectors map (_.rename) filterNot (_ == null)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:211:      beforePickler(individualNames map (targetType nonPrivateMember _))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:217:    /** Complete list of names imported by a wildcard */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:218:    lazy val wildcardNames: List[Name]   = wildcardSymbols map (_.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:219:    lazy val individualNames: List[Name] = selectorRenames filterNot (_ == nme.USCOREkw) flatMap (_.bothNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:221:    /** The names imported by this statement */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:222:    override lazy val importedNames: List[Name] = wildcardNames ++ individualNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/MemberHandlers.scala:223:    lazy val importsSymbolNamed: Set[String] = importedNames map (_.toString) toSet
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:35:    val sn = sessionNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:43:  trait SessionNames {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:61:  lazy val sessionNames: SessionNames = new SessionNames { }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:63:  /** Generates names pre0, pre1, etc. via calls to apply method */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:78:  private lazy val userVar     = new NameCreator(sessionNames.res)  // var name, like res0
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:79:  private lazy val internalVar = new NameCreator(sessionNames.ires) // internal var name, like $ires0
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Naming.scala:81:  def isLineName(name: String)        = (name startsWith sessionNames.line) && (name stripPrefix sessionNames.line forall (_.isDigit))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Power.scala:423:    |Names: %s
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/interpreter/Power.scala:427:      intp.allDefinedNames mkString " ",
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/io/MsilFile.scala:15:class MsilFile(val msilType: MsilType) extends VirtualFile(msilType.FullName, msilType.Namespace) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/matching/ParallelMatching.scala:658:      def params: List[Symbol]      // bound names to be supplied as arguments to labeldef
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/PhaseAssembly.scala:45:      def allPhaseNames(): String = phaseobj match {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/PhaseAssembly.scala:98:     * names are sorted alphabetical at each level, into the compiler phase list
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/PhaseAssembly.scala:290:      sbuf.append("\"" + edge.frm.allPhaseNames + "(" + edge.frm.level + ")" + "\"->\"" + edge.to.allPhaseNames + "(" + edge.to.level + ")" + "\"")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/PhaseAssembly.scala:303:      sbuf.append("\"" + node.allPhaseNames + "(" + node.level + ")" + "\" [color=\"#00ff00\"]\n")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/PhaseAssembly.scala:306:      sbuf.append("\"" + node.allPhaseNames + "(" + node.level + ")" + "\" [color=\"#0000ff\"]\n")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:44:    // remove any with conflicting names or subcomponent names
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:47:      plugNames: Set[String],
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:48:      phaseNames: Set[String]): List[Plugin] =
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:53:      val plugPhaseNames    = Set(plug.components map (_.phaseName): _*)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:54:      def withoutPlug       = pick(tail, plugNames, plugPhaseNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:55:      def withPlug          = plug :: pick(tail, plugNames + plug.name, phaseNames ++ plugPhaseNames)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:56:      lazy val commonPhases = phaseNames intersect plugPhaseNames
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:61:      if (plugNames contains plug.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/plugins/Plugins.scala:66:        fail("[skipping plugin %s because it repeats phase names: " + (commonPhases mkString ", ") + "]")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ScriptRunner.scala:75:    val compSettingNames = new Settings(sys.error).visibleSettings.toList map (_.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/ScriptRunner.scala:76:    val compSettings     = settings.visibleSettings.toList filter (compSettingNames contains _.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/settings/AbsSettings.scala:128:     *  in one place: two AbsSetting objects are equal if their names and
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/settings/MutableSettings.scala:614:   *  phase names. This is not checked here, however.  Alternatively the string
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/settings/ScalaSettings.scala:102:  val resident      = BooleanSetting    ("-Xresident", "Compiler stays resident: read source filenames from standard input.")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/settings/ScalaSettings.scala:159:  val Yshowsymkinds   = BooleanSetting    ("-Yshow-symkinds", "Print abbreviated symbol kinds next to symbol names.")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/settings/StandardScalaSettings.scala:12: *  When possible, the val and the option have identical names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/SubComponent.scala:22:  /** List of phase names, this phase should run after  */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/SubComponent.scala:25:  /** List of phase names, this phase should run before  */
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/AddInterfaces.scala:118:        log(s"${iface.fullLocationString} impl class is ${iface.implClass.nameString}")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/Erasure.scala:929:      //         we do these checks, so that we're comparing same-named methods based on the expanded names that actually
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/ExplicitOuter.scala:163:   *      their names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/ExplicitOuter.scala:561:          // is not suitable; if we make a method-local class non-private, it mangles outer pointer names.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/Mixin.scala:612:     *  defined in StdNames.  If it needs no bitmap, nme.NO_NAME.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/patmat/MatchAnalysis.scala:183:      // the substitution that renames variables to variables in pointsToBound
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/SpecializeTypes.scala:824:          // names after the fact.  And it adds about a billion lines of
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/transform/SpecializeTypes.scala:981:              param.name = overriding.paramss(i)(j).name // SI-6555 Retain the parameter names from the subclass.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Analyzer.scala:24:            with NamesDefaults
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:114:    def name      = tp.typeSymbol.nameString
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:320:          def nameString       = decodeWithKind(name, owner)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:334:                "\npossible cause: maybe a semicolon is missing before `"+nameString+"'?"
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:347:            else s"$nameString is not a member of $targetStr$addendum"
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:485:      //tryNamesDefaults
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:489:      def TooManyArgsNamesDefaultsError(tree: Tree, fun: Tree) =
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1018:        issueNormalTypeError(tree, "Names of vals or vars may not end in `_='")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1183:  object NamesDefaultsErrorsGen {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1197:    def AmbiguousReferenceInNamesDefaultError(arg: Tree, name: Name)(implicit context: Context) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1212:    def UnknownParameterNameNamesDefaultError(arg: Tree, name: Name)(implicit context: Context) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1217:    def DoubleParamNamesDefaultError(arg: Tree, name: Name, pos: Int, otherName: Option[Name])(implicit context: Context) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1226:    def PositionalAfterNamedNamesDefaultError(arg: Tree)(implicit context: Context) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/ContextErrors.scala:1355:    def MacroImplParamNameMismatchError(aparam: Symbol, rparam: Symbol) = compatibilityError("parameter names differ: " + rparam.name + " != " + aparam.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Contexts.scala:634:     *  with the same names. Local symbols override imported ones. This fixes #2866.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Contexts.scala:718:     * methods of nested methods. See NamesDefaults.scala
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Duplicators.scala:309:          def nameSelection = Select(This(newClassOwner), tree.symbol.name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Duplicators.scala:325:                  nameSelection
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Duplicators.scala:328:            else nameSelection
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Implicits.scala:1505:      private lazy val typeParamNames: List[String] = sym.typeParams.map(_.decodedName)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Implicits.scala:1509:        interpolate(msg, Map((typeParamNames zip typeArgs): _*)) // TODO: give access to the name and type of the implicit argument, etc?
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Implicits.scala:1515:        val decls = typeParamNames.toSet
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Implicits.scala:1519:          case unboundNames =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Implicits.scala:1520:            val singular = unboundNames.size == 1
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Implicits.scala:1521:            Some("The type parameter"+( if(singular) " " else "s " )+ unboundNames.mkString(", ")  +
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:38:   *  @param removeByName allows keeping ByName parameters. Used in NamesDefaults.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:39:   *  @param removeRepeated allows keeping repeated parameter (if there's one argument). Used in NamesDefaults.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:297:        val nameStr = try sym.toString catch { case _: CyclicReference => sym.nameString }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:298:        newTermName(s"<error: $nameStr>")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:725:     * similar to the one in NamesDefaults.removeNames.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:727:     * @return a triple (argtpes1, argPos, namesOk) where
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:729:     *    non-parameter names are treated as assignments, i.e. type Unit)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:732:     *  - namesOK is false when there's an invalid use of named arguments
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:734:    private def checkNames(argtpes: List[Type], params: List[Symbol]) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:736:      var positionalAllowed, namesOK = true
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:748:              namesOK = false
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:750:            namesOK = false
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:761:            namesOK = false // positional after named
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:765:      (argtpes1, argPos, namesOK)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:785:     *    an assignment expression (@see checkNames).
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:837:              val (argtpes1, argPos, namesOK) = checkNames(argtpes0, params)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:839:              ( namesOK && (isIdentity(argPos) || sameLength(formals, params)) &&
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:840:              // nb. arguments and names are OK, check if types are compatible
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:1596:      val namesOfArgs = argtpes collect { case NamedType(name, _) => name }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:1597:      val namesMatch = (
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:1598:        if (namesOfArgs.isEmpty) Nil
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:1600:          namesOfArgs forall { name =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:1606:      if (namesMatch.nonEmpty) namesMatch
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Infer.scala:1637:     *    of some NamedType does not exist in an alternative's parameter names,
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/MethodSynthesis.scala:560:    private def beanAccessorsFromNames(tree: ValDef) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/MethodSynthesis.scala:582:      val beans = beanAccessorsFromNames(tree)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Namers.scala:507:          original.bothNames forall (x => (base nonLocalMember x) == NoSymbol)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Namers.scala:529:      def noDuplicates(names: List[Name], check: DuplicatesErrorKinds.Value) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Namers.scala:536:        loop(names filterNot (x => x == null || x == nme.WILDCARD))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Namers.scala:1267:            val names = deftParams map { case TypeDef(_, name, _, _) => name }
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Namers.scala:1268:            val subst = new TypeTreeSubstituter(names contains _)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:18:trait NamesDefaults { self: Analyzer =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:22:  import NamesDefaultsErrorsGen._
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:339:          // type the application without names; put the arguments in definition-site order
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:544:   * Verifies that names are not specified twice, positional args don't appear
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:547:  def removeNames(typer: Typer)(args: List[Tree], params: List[Symbol]): (List[Tree], Array[Int]) = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:572:            else UnknownParameterNameNamesDefaultError(arg, name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:580:            DoubleParamNamesDefaultError(arg, name, existingArgIndex+1, otherName)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:582:            AmbiguousReferenceInNamesDefaultError(arg, name)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/NamesDefaults.scala:594:          else PositionalAfterNamedNamesDefaultError(arg)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/RefChecks.scala:111:      val defaultMethodNames = defaultGetters map (sym => nme.defaultGetterToMethod(sym.name))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/RefChecks.scala:113:      defaultMethodNames.toList.distinct foreach { name =>
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/RefChecks.scala:462:                "The kind of "+member.keyString+" "+member.varianceString + member.nameString+
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/RefChecks.scala:475:                  member.varianceString + member.nameString+ " does not conform to its expected kind."+
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/SuperAccessors.scala:18: *  an abstract override. Finally, the phase also mangles the names
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/SuperAccessors.scala:242:                            + sym.owner + " - you may want to give them distinct names.")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:1813:      // with some confusion of names which leads to having two symbols with the same name in the
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:2119:        case xs  => xs.map(_.nameString).mkString(" (of ", " with ", ")")
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3230:           *  Also works if names + a vararg used: when names are used, the vararg
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3234:          def tryNamesDefaults: Tree = {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3247:              tryTupleApply getOrElse duplErrorTree(TooManyArgsNamesDefaultsError(tree, fun))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3249:              // we don't need defaults. names were used, so this application is transformed
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3250:              // into a block (@see transformNamedApplication in NamesDefaults)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3251:              val (namelessArgs, argPos) = removeNames(Typer.this)(args, params)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3285:              //         determine whether names/defaults is viable *before* transforming trees.
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3290:              def rollbackNamesDefaultsOwnerChanges() {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3314:                  removeNames(Typer.this)(allArgs, params) // #3818
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3322:                  rollbackNamesDefaultsOwnerChanges()
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3334:            else tryNamesDefaults
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3688:            val names = new scala.collection.mutable.HashSet[Symbol]
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3689:            def hasValue = names exists (_.name == nme.value)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3690:            names ++= (if (isJava) annScope.iterator
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3705:                } else if (!names.contains(sym)) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3709:                  names -= sym
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:3718:            for (sym <- names) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:4092:              val nameStringLit = atPos(treeSelection.pos.withStart(treeSelection.pos.point).makeTransparent) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:4095:              atPos(qual.pos)(Apply(fun, List(nameStringLit)))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:5120:                // The symbol names are checked rather than the symbols themselves because
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/typechecker/Typers.scala:5579:        case tree: AssignOrNamedArg             => typedAssign(tree.lhs, tree.rhs) // called by NamesDefaults in silent typecheck
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/DocStrings.scala:135:  /** A map from parameter names to start/end indices describing all parameter
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:57:    val names = new mutable.HashSet[String]
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:66:            names += name
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:79:          names += name
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:86:      if (!names.contains(n))
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:105: * A assembly file (dll / exe) containing classes and namespaces
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:107:class AssemblyClassPath(types: Array[MSILType], namespace: String, val context: MsilContext) extends ClassPath[MsilFile] {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:109:    val i = namespace.lastIndexOf('.')
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:110:    if (i < 0) namespace
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:111:    else namespace drop (i + 1)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:121:      val res = types(l).FullName.compareTo(namespace)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:125:    if (types(m).FullName.startsWith(namespace)) m else types.length
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:131:    while (i < types.length && types(i).Namespace.startsWith(namespace)) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:133:      if (types(i).Namespace == namespace)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:143:    while (i < types.length && types(i).Namespace.startsWith(namespace)) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:144:      val subns = types(i).Namespace
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:145:      if (subns.length > namespace.length) {
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:146:        // example: namespace = "System", subns = "System.Reflection.Emit"
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:148:        val end = subns.indexOf('.', namespace.length + 1)
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/MsilClassPath.scala:162:  override def toString() = "assembly classpath "+ namespace
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/ShowPickled.scala:14:import scala.reflect.internal.{Flags, Names}
./.ensime_cache/dep-src/source-jars/scala/tools/nsc/util/ShowPickled.scala:18:object ShowPickled extends Names {
./.ensime_cache/dep-src/source-jars/scala/tools/util/PathResolver.scala:201:     * and then when typing relative names, instead of picking <root>.scala.relect, typedIdentifier will pick up the
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:55: *  it possible to declare names for subgroups in the pattern.
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:58: *  one associate names with the subgroups.
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:135: *  @param groupNames A mapping from names to indices in capture groups
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:147:class Regex(regex: String, groupNames: String*) extends Serializable {
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:203:  def findAllIn(source: java.lang.CharSequence) = new Regex.MatchIterator(source, this, groupNames)
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:219:        new Match(matchIterator.source, matchIterator.matcher, matchIterator.groupNames).force
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:250:    if (m.find) Some(new Match(source, m, groupNames)) else None
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:284:    if (m.lookingAt) Some(new Match(source, m, groupNames)) else None
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:320:    val it = new Regex.MatchIterator(target, this, groupNames).replacementData
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:347:    val it = new Regex.MatchIterator(target, this, groupNames).replacementData
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:393:  def unanchored: UnanchoredRegex = new Regex(regex, groupNames: _*) with UnanchoredRegex { override def anchored = outer }
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:426:    /** The names of the groups, or some empty sequence if one defined */
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:427:    val groupNames: Seq[String]
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:484:    private lazy val nameToIndex: Map[String, Int] = Map[String, Int]() ++ ("" :: groupNames.toList).zipWithIndex
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:506:              val groupNames: Seq[String]) extends MatchData {
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:566:  class MatchIterator(val source: java.lang.CharSequence, val regex: Regex, val groupNames: Seq[String])
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:605:      def next = { self.next; new Match(source, matcher, groupNames).force }
./.ensime_cache/dep-src/source-jars/scala/util/matching/Regex.scala:612:      def next = { self.next; new Match(source, matcher, groupNames).force }
./.ensime_cache/dep-src/source-jars/scala/util/parsing/ast/AbstractSyntax.scala:23:  /** The base class for elements in the AST that represent names [[scala.util.parsing.ast.Binders]].
./.ensime_cache/dep-src/source-jars/scala/util/parsing/ast/Binders.scala:64: *  combinators will fully enforce the binding discipline. When names are
./.ensime_cache/dep-src/source-jars/scala/util/parsing/ast/Binders.scala:66: *  complemented by an extra phase that resolves names that couldn't be
./.ensime_cache/dep-src/source-jars/scala/util/parsing/ast/Binders.scala:74:  /** A `Scope` keeps track of one or more syntactic elements that represent bound names.
./.ensime_cache/dep-src/source-jars/scala/xml/Atom.scala:33:  final override def doCollectNamespaces = false
./.ensime_cache/dep-src/source-jars/scala/xml/Attribute.scala:56:  def apply(namespace: String, scope: NamespaceBinding, key: String): Seq[Node]
./.ensime_cache/dep-src/source-jars/scala/xml/Attribute.scala:63:  def remove(namespace: String, scope: NamespaceBinding, key: String) =
./.ensime_cache/dep-src/source-jars/scala/xml/Attribute.scala:64:    if (this.key == key && (scope getURI pre) == namespace) next
./.ensime_cache/dep-src/source-jars/scala/xml/Attribute.scala:65:    else copy(next.remove(namespace, scope, key))
./.ensime_cache/dep-src/source-jars/scala/xml/Attribute.scala:69:  def getNamespace(owner: Node): String
./.ensime_cache/dep-src/source-jars/scala/xml/Attribute.scala:71:  def wellformed(scope: NamespaceBinding): Boolean = {
./.ensime_cache/dep-src/source-jars/scala/xml/Comment.scala:20:  final override def doCollectNamespaces = false
./.ensime_cache/dep-src/source-jars/scala/xml/dtd/Scanner.scala:67:        if (isNameStart(c)) name; // NAME
./.ensime_cache/dep-src/source-jars/scala/xml/EntityRef.scala:18:  final override def doCollectNamespaces = false
./.ensime_cache/dep-src/source-jars/scala/xml/factory/LoggedNodeFactory.scala:47:                        scope: NamespaceBinding, children: Seq[Node]): A = {
./.ensime_cache/dep-src/source-jars/scala/xml/factory/NodeFactory.scala:23:  protected def create(pre: String, name: String, attrs: MetaData, scope: NamespaceBinding, children:Seq[Node]): A
./.ensime_cache/dep-src/source-jars/scala/xml/factory/NodeFactory.scala:25:  protected def construct(hash: Int, old:List[A], pre: String, name: String, attrSeq:MetaData, scope: NamespaceBinding, children:Seq[Node]): A = {
./.ensime_cache/dep-src/source-jars/scala/xml/factory/NodeFactory.scala:34:  def nodeEquals(n: Node, pre: String, name: String, attrSeq:MetaData, scope: NamespaceBinding, children: Seq[Node]) =
./.ensime_cache/dep-src/source-jars/scala/xml/factory/NodeFactory.scala:41:  def makeNode(pre: String, name: String, attrSeq: MetaData, scope: NamespaceBinding, children: Seq[Node]): A = {
./.ensime_cache/dep-src/source-jars/scala/xml/include/sax/EncodingHeuristics.scala:28:  object EncodingNames {
./.ensime_cache/dep-src/source-jars/scala/xml/include/sax/EncodingHeuristics.scala:38:  import EncodingNames._
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:34:   * returns normalized MetaData, with all duplicates removed and namespace prefixes resolved to
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:35:   *  namespace URIs via the given scope.
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:37:  def normalize(attribs: MetaData, scope: NamespaceBinding): MetaData = {
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:50:  def getUniversalKey(attrib: MetaData, scope: NamespaceBinding) = attrib match {
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:58:  def update(attribs: MetaData, scope: NamespaceBinding, updates: MetaData): MetaData =
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:66: *  - an instance of `PrefixedAttribute namespace_prefix,key,value` or
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:69: *  Namespace URIs are obtained by using the namespace scope of the element
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:70: *  owning this attribute (see `getNamespace`).
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:84:   *  attributes, namespaces are resolved using the given scope, which defaults to TopScope.
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:89:  def append(updates: MetaData, scope: NamespaceBinding = TopScope): MetaData =
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:100:  /** convenience method, same as `apply(namespace, owner.scope, key)`.
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:102:   *  @param namespace_uri namespace uri of key
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:106:  final def apply(namespace_uri: String, owner: Node, key: String): Seq[Node] =
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:107:    apply(namespace_uri, owner.scope, key)
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:110:   * Gets value of prefixed attribute with given key and namespace, null if not found
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:112:   * @param  namespace_uri namespace uri of key
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:113:   * @param  scp a namespace scp (usually of the element owning this attribute list)
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:117:  def apply(namespace_uri: String, scp: NamespaceBinding, k: String): Seq[Node]
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:123:  /** if owner is the element of this metadata item, returns namespace */
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:124:  def getNamespace(owner: Node): String
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:185:   * @param  uri namespace of key
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:186:   * @param  scope a namespace scp (usually of the element owning this attribute list)
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:190:  final def get(uri: String, scope: NamespaceBinding, key: String): Option[Seq[Node]] =
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:208:  def wellformed(scope: NamespaceBinding): Boolean
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:212:  def remove(namespace: String, scope: NamespaceBinding, key: String): MetaData
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:214:  final def remove(namespace: String, owner: Node, key: String): MetaData =
./.ensime_cache/dep-src/source-jars/scala/xml/MetaData.scala:215:    remove(namespace, owner.scope, key)
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:21:  /** the empty namespace */
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:22:  val EmptyNamespace = ""
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:47:  def doCollectNamespaces = true  // if (tag >= 0) DO collect namespaces
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:51:   *  method returning the namespace bindings of this node. by default, this
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:52:   *  is TopScope, which means there are no namespace bindings except the
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:55:  def scope: NamespaceBinding = TopScope
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:58:   *  convenience, same as <code>getNamespace(this.prefix)</code>
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:60:  def namespace = getNamespace(this.prefix)
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:66:   * @param pre the prefix whose namespace name we would like to obtain
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:67:   * @return    the namespace if <code>scope != null</code> and prefix was
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:70:  def getNamespace(pre: String): String = if (scope eq null) null else scope.getURI(pre)
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:86:   * @param  uri namespace of queried attribute (may not be null).
./.ensime_cache/dep-src/source-jars/scala/xml/Node.scala:88:   * @return value of `PrefixedAttribute` with given namespace
./.ensime_cache/dep-src/source-jars/scala/xml/NodeSeq.scala:83:   *     prefix `"pre"` is resolved to the namespace `"uri"`.
./.ensime_cache/dep-src/source-jars/scala/xml/NodeSeq.scala:130:   *     prefix `"pre"` is resolved to the namespace `"uri"`.
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/ConstructingHandler.scala:24:           pscope: NamespaceBinding, empty: Boolean, nodes: NodeSeq): NodeSeq =
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/FactoryAdapter.scala:34: *  namespace bindings, without relying on namespace handling of the
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/FactoryAdapter.scala:44:  var scopeStack  = new mutable.Stack[NamespaceBinding]
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/FactoryAdapter.scala:63:                 scope: NamespaceBinding, chIter: List[Node]): Node // abstract
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/FactoryAdapter.scala:127:    var scpe: NamespaceBinding =
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/FactoryAdapter.scala:139:        scpe = new NamespaceBinding(arg, nullIfEmpty(value), scpe)
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/NoBindingFactoryAdapter.scala:24:  protected def create(pre: String, label: String, attrs: MetaData, scope: NamespaceBinding, children: Seq[Node]): Elem =
./.ensime_cache/dep-src/source-jars/scala/xml/parsing/NoBindingFactoryAdapter.scala:28:  def createNode(pre: String, label: String, attrs: MetaData, scope: NamespaceBinding, children: List[Node]): Elem =
./.ensime_cache/dep-src/source-jars/scala/xml/PrefixedAttribute.scala:12:/** prefixed attributes always have a non-null namespace.
./.ensime_cache/dep-src/source-jars/scala/xml/PrefixedAttribute.scala:42:  def getNamespace(owner: Node) =
./.ensime_cache/dep-src/source-jars/scala/xml/PrefixedAttribute.scala:43:    owner.getNamespace(pre)
./.ensime_cache/dep-src/source-jars/scala/xml/PrefixedAttribute.scala:50:  def apply(namespace: String, scope: NamespaceBinding, key: String): Seq[Node] = {
./.ensime_cache/dep-src/source-jars/scala/xml/PrefixedAttribute.scala:51:    if (key == this.key && scope.getURI(pre) == namespace)
./.ensime_cache/dep-src/source-jars/scala/xml/PrefixedAttribute.scala:54:      next(namespace, scope, key)
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:104:  protected def startTag(n: Node, pscope: NamespaceBinding): (String, Int) = {
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:138:    node.attribute(XML.namespace, XML.space).map(_.toString == XML.preserve) getOrElse false
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:140:  protected def traverse(node: Node, pscope: NamespaceBinding, ind: Int): Unit =  node match {
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:190:  protected def traverse(it: Iterator[Node], scope: NamespaceBinding, ind: Int ): Unit =
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:197:   *  given namespace to prefix mapping to the given string buffer.
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:206:  def format(n: Node, pscope: NamespaceBinding, sb: StringBuilder) { // entry point
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:237:   *  given namespace to prefix mapping.
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:240:   *  @param pscope the namespace to prefix mapping
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:243:  def format(n: Node, pscope: NamespaceBinding = null): String =
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:249:   *  @param pscope the namespace to prefix mapping
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:251:  def formatNodes(nodes: Seq[Node], pscope: NamespaceBinding = null): String =
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:255:   *  the given namespace to prefix mapping to the given stringbuffer.
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:258:   *  @param pscope the namespace to prefix mapping
./.ensime_cache/dep-src/source-jars/scala/xml/PrettyPrinter.scala:261:  def formatNodes(nodes: Seq[Node], pscope: NamespaceBinding, sb: StringBuilder): Unit =
./.ensime_cache/dep-src/source-jars/scala/xml/ProcInstr.scala:27:  final override def doCollectNamespaces = false
./.ensime_cache/dep-src/source-jars/scala/xml/pull/XMLEventReader.scala:71:    override def elemStart(pos: Int, pre: String, label: String, attrs: MetaData, scope: NamespaceBinding) {
./.ensime_cache/dep-src/source-jars/scala/xml/pull/XMLEventReader.scala:84:    final def elem(pos: Int, pre: String, label: String, attrs: MetaData, pscope: NamespaceBinding, empty: Boolean, nodes: NodeSeq): NodeSeq =
./.ensime_cache/dep-src/source-jars/scala/xml/SpecialNode.scala:24:  /** always Node.EmptyNamespace */
./.ensime_cache/dep-src/source-jars/scala/xml/SpecialNode.scala:25:  final override def namespace = null
./.ensime_cache/dep-src/source-jars/scala/xml/UnprefixedAttribute.scala:12:/** Unprefixed attributes have the null namespace, and no prefix field
./.ensime_cache/dep-src/source-jars/scala/xml/UnprefixedAttribute.scala:36:  final def getNamespace(owner: Node): String = null
./.ensime_cache/dep-src/source-jars/scala/xml/UnprefixedAttribute.scala:50:   * @param  namespace
./.ensime_cache/dep-src/source-jars/scala/xml/UnprefixedAttribute.scala:55:  def apply(namespace: String, scope: NamespaceBinding, key: String): Seq[Node] =
./.ensime_cache/dep-src/source-jars/scala/xml/UnprefixedAttribute.scala:56:    next(namespace, scope, key)
./.ensime_cache/dep-src/source-jars/scala/xml/XML.scala:60:  val namespace = "http://www.w3.org/XML/1998/namespace"
./.ensime_cache/dep-src/source-jars/scalaz/Reducer.scala:11: * and are used when appropriate by a [[scalaz.Generator]]. The names `cons` and `snoc` work
./.ensime_cache/dep-src/source-jars/shapeless/generic.scala:501:      val elemInstanceNames = List.fill(elemTpes.length)(newTermName(c.fresh("inst")))
./.ensime_cache/dep-src/source-jars/shapeless/generic.scala:502:      val elemInstanceMap = (elemTpes zip elemInstanceNames).toMap
./.ensime_cache/dep-src/source-jars/shapeless/typeclass.scala:60: * corresponding to the names of the product elements.
./agent/src/main/scala/jmx/Import.scala:120:    val getAttributeNames: ObjectName => Set[(ObjectName,Attribute)] = { on =>
./agent/src/main/scala/jmx/Import.scala:126:    svr.toScala.queryNames(query).flatMap(getAttributeNames)
./agent/src/main/scala/jmx/Import.scala:132:  private[jmx] def readableAttributeNames(svr: MBeanServerConnection, query: Option[MBeanQuery]): Set[String] = {
./agent/src/main/scala/jmx/Import.scala:133:    val getAttributeNames: ObjectName => Set[String] = on =>
./agent/src/main/scala/jmx/Import.scala:136:      svr.toScala.queryNames(q).flatMap(getAttributeNames) }, Set.empty[String])
./agent/src/test/scala/jmx/ParserSpec.scala:10:  it should "parse zookeeper bean names" in {
./agent/src/test/scala/jmx/ParserSpec.scala:15:  it should "parse cassandra bean names" in {
./aws/src/main/scala/ASG.scala:66:      ).withAutoScalingGroupNames(name)
./core/src/main/scala/AttributeKeys.scala:4: * Hard-coded attribute key names. These really should be types, not strings.
./core/src/main/scala/Monitoring.scala:142:    nodeRetries: Names => Event = _ => defaultRetries
./core/src/main/scala/Monitoring.scala:176:            attemptMirrorAll(parse)(nodeRetries(Names(cluster, myName, localName)))(
./core/src/main/scala/Names.scala:3:final case class Names(kind: String, mine: String, theirs: String)
./flask/src/main/scala/main.scala:13:import funnel.{Events,DatapointParser,Datapoint,Names,Sigar,Monitoring,Instruments}
./flask/src/main/scala/main.scala:86:    def retries(names: Names): Event =
./flask/src/main/scala/main.scala:88:        Q.enqueueOne(Error(names))
./flask/src/main/scala/main.scala:89:          .flatMap(_ => Task.delay(log.error("stopped mirroring: " + names.toString)))))
./messages/src/main/scala/telemetry.scala:17:final case class Error(names: Names) extends Telemetry {
./messages/src/main/scala/telemetry.scala:18:  override def toString = s"${names.mine} gave up on ${names.kind} server ${names.theirs}"
./messages/src/main/scala/telemetry.scala:99:  implicit lazy val errorCodec = Codec.derive[Names].xmap[Error](Error(_), _.names)
./messages/src/multi-jvm/scala/TelemetrySocketSpec.scala:29:    Error(Names("kind1", "mine", "theirs")),
./messages/src/multi-jvm/scala/TelemetrySocketSpec.scala:30:    Error(Names("kind2", "mine", "theirs")),
./messages/src/multi-jvm/scala/TelemetrySocketSpec.scala:31:    Error(Names("kind3", "mine", "theirs")),
./messages/src/multi-jvm/scala/TelemetrySocketSpec.scala:32:    Error(Names("kind4", "mine", "theirs"))
./riemann/src/main/scala/Riemann.scala:147:    riemannRetries: Names => Event = _ => Monitoring.defaultRetries)(
./riemann/src/main/scala/Riemann.scala:153:    publish(M, ttlInSeconds, riemannRetries(Names("Riemann", myName, riemannName)))(riemannClient, actor)

Grep finished (matches found) at Sat May  2 09:48:17
